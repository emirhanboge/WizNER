{
    "id": "5783",
    "revid": "4141788",
    "url": "https://en.wikipedia.org/wiki?curid=5783",
    "title": "Computer program",
    "text": "In &lt;a href=\"imperative%20programming\"&gt;imperative programming&lt;/a&gt;, a computer program is a sequence of instructions in a &lt;a href=\"programming%20language\"&gt;programming language&lt;/a&gt; that a &lt;a href=\"computer\"&gt;computer&lt;/a&gt; can execute or interpret. In &lt;a href=\"declarative%20programming\"&gt;declarative programming&lt;/a&gt;, a \"computer program\" is a &lt;a href=\"Set%20%28mathematics%29\"&gt;set&lt;/a&gt; of instructions.\nA computer program in its human-readable form is called &lt;a href=\"source%20code\"&gt;source code&lt;/a&gt;. Source code needs another computer program to &lt;a href=\"Execution%20%28computing%29\"&gt;execute&lt;/a&gt; because computers can only execute their native &lt;a href=\"machine%20code\"&gt;machine instructions&lt;/a&gt;. Therefore, source code may be translated to machine instructions using the language's &lt;a href=\"compiler\"&gt;compiler&lt;/a&gt;. (&lt;a href=\"Machine%20language\"&gt;Machine language&lt;/a&gt; programs are translated using an &lt;a href=\"Assembly%20language%23Assembler\"&gt;assembler&lt;/a&gt;.) The resulting file is called an &lt;a href=\"executable\"&gt;executable&lt;/a&gt;. Alternatively, source code may execute within the language's &lt;a href=\"interpreter%20%28computing%29\"&gt;interpreter&lt;/a&gt;. The programming language &lt;a href=\"Java%20%28programming%20language%29\"&gt;Java&lt;/a&gt; compiles into an &lt;a href=\"Java%20bytecode\"&gt;a intermediate form&lt;/a&gt; which is then executed by a &lt;a href=\"Java%20virtual%20machine\"&gt;Java interpreter&lt;/a&gt;.\nIf the executable is requested for execution, then the &lt;a href=\"operating%20system\"&gt;operating system&lt;/a&gt; loads it into &lt;a href=\"Random-access%20memory\"&gt;memory&lt;/a&gt; and starts a &lt;a href=\"Process%20%28computing%29\"&gt;process&lt;/a&gt;. The &lt;a href=\"central%20processing%20unit\"&gt;central processing unit&lt;/a&gt; will soon &lt;a href=\"Context%20switch\"&gt;switch&lt;/a&gt; to this process so it can &lt;a href=\"Instruction%20cycle\"&gt;fetch, decode, and then execute&lt;/a&gt; each machine instruction.\nIf the source code is requested for execution, then the operating system loads the corresponding interpreter into memory and starts a process. The interpreter then loads the source code into memory to translate and execute each statement. Running the source code is slower than running an executable. Moreover, the interpreter must be installed on the computer.\nHistory.\nAnalytical Engine.\nIn 1837, &lt;a href=\"Charles%20Babbage\"&gt;Charles Babbage&lt;/a&gt; was inspired by &lt;a href=\"Jacquard%20machine\"&gt;Jacquard's loom&lt;/a&gt; to attempt to build the &lt;a href=\"Analytical%20Engine\"&gt;Analytical Engine&lt;/a&gt;.\nThe names of the components of the calculating device were borrowed from the textile industry. In the textile industry, yarn was brought from the store to be milled. The device had a \"store\" which was memory to hold 1,000 numbers of 50 decimal digits each. Numbers from the \"store\" were transferred to the \"mill\" for processing. It was programmed using two sets of perforated cards. One set to direct the operation and the other for the input variables.\n However, after more than 17,000 pounds of the British government's money, the thousands of cogged wheels and gears never fully worked together.\n&lt;a href=\"Ada%20Lovelace\"&gt;Ada Lovelace&lt;/a&gt; worked for Charles Babbage to create a description of the Analytical Engine (1843). The description contained Note G which completely detailed a method for calculating &lt;a href=\"Bernoulli%20number\"&gt;Bernoulli number&lt;/a&gt;s using the Analytical Engine. This note is recognized by some historians as the world's first published computer program.\nUniversal Turing machine.\nIn 1936, &lt;a href=\"Alan%20Turing\"&gt;Alan Turing&lt;/a&gt; introduced the &lt;a href=\"Universal%20Turing%20machine\"&gt;Universal Turing machine&lt;/a&gt;\u2014a theoretical device that can model every computation that can be performed on a &lt;a href=\"Turing%20complete\"&gt;Turing complete&lt;/a&gt; computing machine.\nIt is a &lt;a href=\"finite-state%20machine\"&gt;finite-state machine&lt;/a&gt; that has an infinitely long read/write tape. The machine can move the tape back and forth, changing its contents as it performs an &lt;a href=\"algorithm\"&gt;algorithm&lt;/a&gt;. The machine starts in the initial state, goes through a sequence of steps, and halts when it encounters the halt state.\nRelay-based computers.\nThe &lt;a href=\"Z3%20%28computer%29\"&gt;Z3 computer&lt;/a&gt;, invented by &lt;a href=\"Konrad%20Zuse\"&gt;Konrad Zuse&lt;/a&gt; (1941), was a digital and programmable computer. Zuse became aware of the \"Babbage Engine\" in 1939 while attempting to file a &lt;a href=\"Germany\"&gt;German&lt;/a&gt; patent. The \"Analytical Engine\" was &lt;a href=\"base-10\"&gt;base-10&lt;/a&gt; \u2014 which was easy to comprehend. Zuse recognized that a &lt;a href=\"Binary%20code\"&gt;binary&lt;/a&gt; machine was easy to construct. &lt;a href=\"Relay\"&gt;Telephone relays&lt;/a&gt; are two-position switches \u2014 open or closed. The Z3 had approximately 2,600 relays: 1,800 for the memory, 600 for the arithmetic, and 200 for the &lt;a href=\"punched%20tape\"&gt;punch tape&lt;/a&gt; reader, keyboard, and display. The circuits provided a &lt;a href=\"floating-point\"&gt;floating-point&lt;/a&gt;, nine-instruction computer. Programming the Z3 was through a specially designed keyboard and punch tape. Manual input was through a calculator-style keyboard that accepted decimal numbers. The machine converted the input to binary and passed them through a series of calculating modules. The result was converted back to decimal and displayed on an output panel.\nSimultaneously developed was its successor \u2014 the &lt;a href=\"Z4%20%28computer%29\"&gt;Z4 computer&lt;/a&gt;. (An air-raid on April 6, 1945 destroyed the Z3.) In 1950, the Z4 was placed into production at the &lt;a href=\"ETH%20Zurich\"&gt;Federal Technical Institute in Zurich&lt;/a&gt;.\nThe &lt;a href=\"Harvard%20Mark%20I\"&gt;Harvard Mark I&lt;/a&gt;, invented by &lt;a href=\"IBM\"&gt;IBM&lt;/a&gt; (1944), also was a digital and programmable computer. The computer supported 23 signed integer digits and had seven major units:\nThe Harvard Mark I had 3,304 relays and 530 miles of wire. Two &lt;a href=\"punched%20tape\"&gt;punched tape&lt;/a&gt; readers provided input. One reader inputted the instructions. A code book was written by &lt;a href=\"Howard%20H.%20Aiken\"&gt;Howard H. Aiken&lt;/a&gt; that indexed the available algorithms. From this book, a programmer punched the coded instructions onto a tape. The other reader inputted the data to be processed.\nThe Harvard Mark I was succeeded by IBM's two other relay-based computers:\nENIAC.\nThe &lt;a href=\"ENIAC\"&gt;Electronic Numerical Integrator And Computer&lt;/a&gt; (ENIAC) was built between July 1943 and Fall 1945. It was a &lt;a href=\"Turing%20complete\"&gt;Turing complete&lt;/a&gt;, general-purpose computer that used 17,468 &lt;a href=\"vacuum%20tube\"&gt;vacuum tube&lt;/a&gt;s to create the &lt;a href=\"Electronic%20circuit\"&gt;circuits&lt;/a&gt;. At its core, it was a series of &lt;a href=\"Pascaline\"&gt;Pascaline&lt;/a&gt;s wired together. Its 40 units weighed 30 tons, occupied , and consumed $650 per hour (&lt;a href=\"Inflation\"&gt;in 1940s currency&lt;/a&gt;) in electricity when idle. It had 20 &lt;a href=\"base-10\"&gt;base-10&lt;/a&gt; &lt;a href=\"Accumulator%20%28computing%29\"&gt;accumulators&lt;/a&gt;. Programming the ENIAC took up to two months. Three function tables were on wheels and needed to be rolled to fixed function panels. Function tables were connected to function panels using heavy black cables. Each function table had 728 rotating knobs. Programming the ENIAC also involved setting some of the 3,000 switches. Debugging a program took a week. It ran from 1947 until 1955 at &lt;a href=\"Aberdeen%20Proving%20Ground\"&gt;Aberdeen Proving Ground&lt;/a&gt;, calculating hydrogen bomb parameters, predicting weather patterns, and producing firing tables to aim artillery guns.\nStored-program computers.\nInstead of plugging in cords and turning switches, a &lt;a href=\"stored-program%20computer\"&gt;stored-program computer&lt;/a&gt; loads its instructions into memory just like it loads its data into memory. As a result, the computer could be programmed quickly and perform calculations at very fast speeds. &lt;a href=\"J.%20Presper%20Eckert\"&gt;Presper Eckert&lt;/a&gt; and &lt;a href=\"John%20Mauchly\"&gt;John Mauchly&lt;/a&gt; built the ENIAC. The two engineers introduced the \"stored-program concept\" in a three-page memo dated February 1944. Later, in September 1944, &lt;a href=\"John%20von%20Neumann\"&gt;Dr. John von Neumann&lt;/a&gt; began working on the ENIAC project. On June 30, 1945, von Neumann published the \"&lt;a href=\"First%20Draft%20of%20a%20Report%20on%20the%20EDVAC\"&gt;First Draft of a Report on the EDVAC&lt;/a&gt;\" which equated the structures of the computer with the structures of the human brain. The design became known as the &lt;a href=\"von%20Neumann%20architecture\"&gt;von Neumann architecture&lt;/a&gt;. The architecture was simultaneously deployed in the constructions of the &lt;a href=\"EDVAC\"&gt;EDVAC&lt;/a&gt; and &lt;a href=\"EDSAC\"&gt;EDSAC&lt;/a&gt; computers in 1949.\nIn 1961, the &lt;a href=\"Burroughs%20large%20systems%23B5000\"&gt;Burroughs B5000&lt;/a&gt; was built specifically to be programmed in the &lt;a href=\"ALGOL%2060\"&gt;Algol 60&lt;/a&gt; language. The hardware featured circuits to ease the &lt;a href=\"compiler\"&gt;compile&lt;/a&gt; phase.\nIn 1964, the &lt;a href=\"IBM%20System/360\"&gt;IBM System/360&lt;/a&gt; was a line of six computers each having the same &lt;a href=\"instruction%20set\"&gt;instruction set architecture&lt;/a&gt;. The &lt;a href=\"IBM%20System/360%20Model%2030\"&gt;Model 30&lt;/a&gt; was the smallest and least expensive. Customers could upgrade and retain the same &lt;a href=\"application%20software\"&gt;application software&lt;/a&gt;. The &lt;a href=\"IBM%20System/360%20Model%2075\"&gt;Model 75&lt;/a&gt; was the most premium. Each System/360 model featured &lt;a href=\"Computer%20multitasking%23Multiprogramming\"&gt;multiprogramming&lt;/a&gt; \u2014 having multiple &lt;a href=\"Process%20%28computing%29\"&gt;processes&lt;/a&gt; in &lt;a href=\"random-access%20memory\"&gt;memory&lt;/a&gt; at once. When one process was waiting for &lt;a href=\"input/output\"&gt;input/output&lt;/a&gt;, another could compute.\nIBM planned for each model to be programmed using &lt;a href=\"PL/1\"&gt;PL/1&lt;/a&gt;. A committee was formed that included &lt;a href=\"COBOL\"&gt;COBOL&lt;/a&gt;, &lt;a href=\"Fortran\"&gt;Fortran&lt;/a&gt; and &lt;a href=\"ALGOL\"&gt;ALGOL&lt;/a&gt; programmers. The purpose was to develop a language that was comprehensive, easy to use, extendible, and would replace Cobol and Fortran. The result was a large and complex language that took a long time to &lt;a href=\"Compiler\"&gt;compile&lt;/a&gt;.\nComputers manufactured until the 1970s had front-panel switches for manual programming. The computer program was written on paper for reference. An instruction was represented by a configuration of on/off settings. After setting the configuration, an execute button was pressed. This process was then repeated. Computer programs also were automatically inputted via &lt;a href=\"paper%20tape\"&gt;paper tape&lt;/a&gt; or &lt;a href=\"punched%20cards\"&gt;punched cards&lt;/a&gt;. After the medium was loaded, the starting address was set via switches, and the execute button was pressed.\nVery Large Scale Integration.\nA major milestone in software development was the invention of the &lt;a href=\"Very%20Large%20Scale%20Integration\"&gt;Very Large Scale Integration&lt;/a&gt; (VLSI) circuit (1964). Following World War II, tube based technology was replaced with &lt;a href=\"transistor\"&gt;transistor&lt;/a&gt;s on a &lt;a href=\"circuit%20board\"&gt;circuit board&lt;/a&gt;. During the 1960s, the &lt;a href=\"aerospace\"&gt;aerospace&lt;/a&gt; industry replaced the circuit board with a single &lt;a href=\"integrated%20circuit\"&gt;integrated circuit&lt;/a&gt; chip.\nOriginally, integrated circuit chips had their function set during manufacturing. During the 1960s, controlling the electrical flow migrated to programming a &lt;a href=\"Diode%20matrix\"&gt;matrix&lt;/a&gt; of &lt;a href=\"read-only%20memory\"&gt;read-only memory&lt;/a&gt; (ROM). The matrix resembled a two dimensional array of fuses. The process to embed instructions onto the matrix was to burn out the unneeded connections. There are so many connections, &lt;a href=\"firmware\"&gt;firmware&lt;/a&gt; programmers wrote a &lt;a href=\"microcode\"&gt;microcode computer program&lt;/a&gt; on another chip to oversee the burning. The technology became known as &lt;a href=\"Programmable%20ROM\"&gt;Programmable ROM&lt;/a&gt;. In 1971, an entire micro-programmable computer (&lt;a href=\"microprocessor\"&gt;microprocessor&lt;/a&gt;) was fitted onto a single &lt;a href=\"Intel%204004\"&gt;Intel 4004&lt;/a&gt; chip.\nSac State 8008.\nThe Intel 4004 was a 4-bit microprocessor and functioned to run the &lt;a href=\"Busicom\"&gt;Busicom&lt;/a&gt; calculator. Five months after its release, Intel released the &lt;a href=\"Intel%208008\"&gt;Intel 8008&lt;/a&gt; \u2014 an 8-bit microprocessor. The first computer built using the Intel 8008 was the \"Sac State 8008\" (1972). Its purpose was to store patient medical records. The &lt;a href=\"California%20State%20University%2C%20Sacramento\"&gt;Sacramento State&lt;/a&gt; computer supported a &lt;a href=\"disk%20operating%20system\"&gt;disk operating system&lt;/a&gt; to run a &lt;a href=\"Memorex\"&gt;Memorex&lt;/a&gt; 3-&lt;a href=\"megabyte\"&gt;megabyte&lt;/a&gt; &lt;a href=\"hard%20disk%20drive\"&gt;hard disk drive&lt;/a&gt;. It had a color display and keyboard that was packaged in a single console. The disk operating system was programmed using &lt;a href=\"IBM%20Basic%20Assembly%20Language%20and%20successors\"&gt;IBM's Basic Assembly Language (BAL)&lt;/a&gt;. The medical records application was programmed using a &lt;a href=\"BASIC\"&gt;BASIC&lt;/a&gt; interpreter. However, the computer was an evolutionary dead-end because it was extremely expensive. Also, it was built at a public university lab for a specific purpose. Nonetheless, the project contributed to the development of the &lt;a href=\"Intel%208080\"&gt;Intel 8080&lt;/a&gt; &lt;a href=\"Instruction_set_architecture\"&gt;instruction set&lt;/a&gt;.\nProgramming languages.\n&lt;a href=\"Computer%20programming\"&gt;Computer programming&lt;/a&gt; (also known as &lt;a href=\"software%20development\"&gt;software development&lt;/a&gt; and &lt;a href=\"software%20engineering\"&gt;software engineering&lt;/a&gt;) is the process of writing or editing &lt;a href=\"source%20code\"&gt;source code&lt;/a&gt;. In a formal environment, a &lt;a href=\"systems%20analyst\"&gt;systems analyst&lt;/a&gt; will gather information from managers about all the organization's processes to automate. This professional then prepares a &lt;a href=\"Functional%20requirement\"&gt;detailed plan&lt;/a&gt; for the new or modified system. The plan is analogous to an architect's blueprint. A &lt;a href=\"computer%20programmer\"&gt;computer programmer&lt;/a&gt; is a specialist responsible for writing or modifying the source code to implement the detailed plan.\nHello world program.\nThe &lt;a href=\"%26quot%3BHello%2C%20World%21%26quot%3B%20program\"&gt;\"Hello, World!\" program&lt;/a&gt; is a few instructions used to illustrate the basic &lt;a href=\"Input/output\"&gt;output&lt;/a&gt; rules of a &lt;a href=\"programming%20language\"&gt;programming language&lt;/a&gt;.\nA \"programming language\" is a set of &lt;a href=\"Reserved%20word\"&gt;keywords&lt;/a&gt;, &lt;a href=\"Character%20%28computing%29\"&gt;symbols&lt;/a&gt;, &lt;a href=\"Identifier%20%28computer%20languages%29\"&gt;identifiers&lt;/a&gt;, and rules by which programmers can communicate instructions to the computer. They follow a set of rules called a &lt;a href=\"Syntax%20%28programming%20languages%29\"&gt;syntax&lt;/a&gt;.\n\"Programming languages\" get their basis from &lt;a href=\"formal%20language\"&gt;formal languages&lt;/a&gt;. The purpose of defining a solution in terms of its \"formal language\" is to generate an &lt;a href=\"algorithm\"&gt;algorithm&lt;/a&gt; to solve the underlining problem. An \"algorithm\" is a sequence of simple instructions that solve a problem.\nGeneration of programming languages.\nThe evolution of programming languages began when the &lt;a href=\"EDSAC\"&gt;EDSAC&lt;/a&gt; (1949) used the first &lt;a href=\"Stored-program%20computer\"&gt;stored computer program&lt;/a&gt; in its &lt;a href=\"von%20Neumann%20architecture\"&gt;von Neumann architecture&lt;/a&gt;. Programming the EDSAC was in the first &lt;a href=\"Programming%20language%20generations\"&gt;generation of programming languages&lt;/a&gt;.\nImperative languages.\n\"Imperative languages\" specify a sequential &lt;a href=\"algorithm%23Computer%20algorithm\"&gt;algorithm&lt;/a&gt; using declarations, expressions, and statements:\nFortran.\n&lt;a href=\"FORTRAN\"&gt;FORTRAN&lt;/a&gt; (1958) was unveiled as \"The IBM Mathematical FORmula TRANslating system.\" It first compiled correctly in 1958. It was designed for scientific calculations, without &lt;a href=\"String%20%28computer%20science%29\"&gt;string&lt;/a&gt; handling facilities. Along with \"declarations\", \"expressions\" and \"statements\", it supported:\nIt succeeded because:\nHowever, non IBM vendors also wrote Fortran compilers, but with a syntax that would likely fail IBM's compiler. The &lt;a href=\"American%20National%20Standards%20Institute\"&gt;American National Standards Institute&lt;/a&gt; (ANSI) developed the first Fortran standard in 1966. In 1978, Fortran 77 became the standard until 1991. Fortran 90 supports:\nCOBOL.\n&lt;a href=\"COBOL\"&gt;COBOL&lt;/a&gt; (1959) stands for \"COmmon Business Oriented Language.\" Fortran manipulated symbols. It was soon realized that symbols didn't need to be numbers, so strings were introduced. The &lt;a href=\"US%20Department%20of%20Defense\"&gt;US Department of Defense&lt;/a&gt; influenced COBOL's development, with &lt;a href=\"Grace%20Hopper\"&gt;Grace Hopper&lt;/a&gt; being a major contributor. The statements were English-like and verbose. The goal was to design a language so managers could read the programs. However, the lack of structured statements hindered this goal.\nCOBOL's development was tightly controlled, so dialects didn't emerge to require ANSI standards. As a consequence, it wasn't changed for 25 years until 1974. The 1990s version did make consequential changes like &lt;a href=\"object-oriented%20programming\"&gt;object-oriented programming&lt;/a&gt;.\nAlgol.\n&lt;a href=\"ALGOL\"&gt;ALGOL&lt;/a&gt; (1960) stands for \"ALGOrithmic Language.\" It had a profound influence on programming language design. Emerging from a committee of European and American programming language experts, it used standard mathematical notation and had a readable structured design. Algol was first to define its &lt;a href=\"Syntax%20%28programming%20languages%29\"&gt;syntax&lt;/a&gt; using the &lt;a href=\"Backus%E2%80%93Naur%20form\"&gt;Backus\u2013Naur form&lt;/a&gt;. This led to &lt;a href=\"Syntax-directed%20translation\"&gt;syntax-directed&lt;/a&gt; compilers. It added features like:\nAlgol's direct descendants include &lt;a href=\"Pascal%20%28programming%20language%29\"&gt;Pascal&lt;/a&gt;, &lt;a href=\"Modula-2\"&gt;Modula-2&lt;/a&gt;, &lt;a href=\"Ada%20%28programming%20language%29\"&gt;Ada&lt;/a&gt;, &lt;a href=\"Delphi%20%28software%29\"&gt;Delphi&lt;/a&gt; and &lt;a href=\"Oberon%20%28programming%20language%29\"&gt;Oberon&lt;/a&gt; on one branch. On another branch there's &lt;a href=\"C%20%28programming%20language%29\"&gt;C&lt;/a&gt;, &lt;a href=\"C%2B%2B\"&gt;C++&lt;/a&gt; and &lt;a href=\"Java%20%28programming%20language%29\"&gt;Java&lt;/a&gt;.\nBasic.\n&lt;a href=\"BASIC\"&gt;BASIC&lt;/a&gt; (1964) stands for \"Beginner's All Purpose Symbolic Instruction Code.\" It was developed at &lt;a href=\"Dartmouth%20College\"&gt;Dartmouth College&lt;/a&gt; for all of their students to learn. If a student didn't go on to a more powerful language, the student would still remember Basic. A Basic interpreter was installed in the &lt;a href=\"microcomputers\"&gt;microcomputers&lt;/a&gt; manufactured in the late 1970s. As the microcomputer industry grew, so did the language. \nBasic pioneered the &lt;a href=\"Read%E2%80%93eval%E2%80%93print%20loop\"&gt;interactive session&lt;/a&gt;. It offered &lt;a href=\"operating%20system\"&gt;operating system&lt;/a&gt; commands within its environment:\nHowever, the Basic syntax was too simple for large programs. Recent dialects have added structure and object-oriented extensions. &lt;a href=\"Microsoft\"&gt;Microsoft's&lt;/a&gt; &lt;a href=\"Visual%20Basic\"&gt;Visual Basic&lt;/a&gt; is still widely used and produces a &lt;a href=\"graphical%20user%20interface\"&gt;graphical user interface&lt;/a&gt;.\nC.\n&lt;a href=\"C%20%28programming%20language%29\"&gt;C programming language&lt;/a&gt; (1973) got its name because the language &lt;a href=\"BCPL\"&gt;BCPL&lt;/a&gt; was replaced with &lt;a href=\"B%20%28programming%20language%29\"&gt;B&lt;/a&gt;, and &lt;a href=\"Bell%20Labs\"&gt;AT&amp;T Bell Labs&lt;/a&gt; called the next version \"C.\" Its purpose was to write the &lt;a href=\"UNIX\"&gt;UNIX&lt;/a&gt; &lt;a href=\"operating%20system\"&gt;operating system&lt;/a&gt;. C is a relatively small language -- making it easy to write compilers. Its growth mirrored the hardware growth in the 1980s. Its growth also was because it has the facilities of &lt;a href=\"assembly%20language\"&gt;assembly language&lt;/a&gt;, but uses a &lt;a href=\"High-level%20programming%20language\"&gt;high-level syntax&lt;/a&gt;. It added advanced features like:\n\"C\" allows the programmer to control which region of memory data is to be stored. \"Global variables\" and \"static variables\" require the fewest &lt;a href=\"Clock%20signal\"&gt;clock cycles&lt;/a&gt; to store. The \"stack\" is automatically used for the standard variable declarations. \"Heap\" memory is returned to a \"pointer variable\" from the &lt;a href=\"C%20dynamic%20memory%20allocation\"&gt;codice_4&lt;/a&gt; function.\nC++.\nIn the 1970s, &lt;a href=\"software%20engineering\"&gt;software engineers&lt;/a&gt; needed language support to break large projects down into &lt;a href=\"Modular_programming\"&gt;modules&lt;/a&gt;. One obvious feature was to decompose large projects \"physically\" into separate &lt;a href=\"computer%20file\"&gt;files&lt;/a&gt;. A less obvious feature was to decompose large projects \"logically\" into &lt;a href=\"Abstract%20and%20concrete\"&gt;abstract&lt;/a&gt; &lt;a href=\"Data%20type\"&gt;datatypes&lt;/a&gt;. At the time, languages supported concrete (&lt;a href=\"Variable%20%28computer%20science%29\"&gt;scalar&lt;/a&gt;) datatypes like &lt;a href=\"integer\"&gt;integer&lt;/a&gt; numbers, &lt;a href=\"Floating-point%20arithmetic\"&gt;floating-point&lt;/a&gt; numbers, and &lt;a href=\"String%20%28computer%20science%29\"&gt;strings&lt;/a&gt; of &lt;a href=\"Character%20%28computing%29\"&gt;characters&lt;/a&gt;. Concrete datatypes have their representation as part of their name. Abstract datatypes are &lt;a href=\"Record%20%28computer%20science%29\"&gt;structures&lt;/a&gt; of concrete datatypes \u2014 with a new name assigned. For example, a &lt;a href=\"List%20%28abstract%20data%20type%29\"&gt;list&lt;/a&gt; of integers could be called codice_14.\nIn object-oriented jargon, abstract datatypes are called &lt;a href=\"Class%20%28computer%20programming%29\"&gt;classes&lt;/a&gt;. However, a \"class\" is only a definition; no memory is allocated. When memory is allocated to a class, it's called an &lt;a href=\"Object%20%28computer%20science%29\"&gt;object&lt;/a&gt;.\n\"&lt;a href=\"Object-oriented%20programming\"&gt;Object-oriented imperative languages&lt;/a&gt;\" developed by combining the need for classes and the need for safe &lt;a href=\"functional%20programming\"&gt;functional programming&lt;/a&gt;. A function, in an object-oriented language, is assigned to a class. An assigned function is then referred to as a &lt;a href=\"Method%20%28computer%20programming%29\"&gt;method&lt;/a&gt;, &lt;a href=\"Method_%28computer_programming%29%23Member_functions_in_C%2B%2B\"&gt;member function&lt;/a&gt;, or \"&lt;a href=\"Operation%20%28mathematics%29\"&gt;operation&lt;/a&gt;\". \"Object-oriented programming\" is executing \"operations\" on \"objects\".\n\"Object-oriented languages\" support a syntax to model &lt;a href=\"subset\"&gt;subset/superset&lt;/a&gt; relationships. In &lt;a href=\"set%20theory\"&gt;set theory&lt;/a&gt;, an &lt;a href=\"Element%20%28mathematics%29\"&gt;element&lt;/a&gt; of a subset inherits all the attributes contained in the superset. For example, a student is a person. Therefore, the set of students is a subset of the set of persons. As a result, students inherit all the attributes common to all persons. Additionally, students have unique attributes that other persons don't have. \"Object-oriented languages\" model \"subset/superset\" relationships using &lt;a href=\"Inheritance%20%28object-oriented%20programming%29\"&gt;inheritance&lt;/a&gt;. \"Object-oriented programming\" became the dominant language paradigm by the late 1990s.\n&lt;a href=\"C%2B%2B\"&gt;C++&lt;/a&gt; (1985) was originally called \"C with Classes.\" It was designed to expand &lt;a href=\"C%20%28programming%20language%29\"&gt;C's&lt;/a&gt; capabilities by adding the object-oriented facilities of the language &lt;a href=\"Simula\"&gt;Simula&lt;/a&gt;.\nAn object-oriented module is composed of two files. The definitions file is called the &lt;a href=\"Include%20directive\"&gt;header file&lt;/a&gt;. Here is a C++ \"header file\" for the \"GRADE class\" in a simple school application:\n// grade.h\n// Used to allow multiple source files to include\n// this header file without duplication errors.\nclass GRADE {\npublic:\n // This is the constructor operation.\n GRADE ( const char letter );\n // This is a class variable.\n char letter;\n // This is a member operation.\n int grade_numeric( const char letter );\n // This is a class variable.\n int numeric;\nA &lt;a href=\"Constructor%20%28object-oriented%20programming%29\"&gt;constructor&lt;/a&gt; operation is a function with the same name as the class name. It is executed when the calling operation executes the codice_15 statement.\nA module's other file is the \"source file\". Here is a C++ source file for the \"GRADE class\" in a simple school application:\n// grade.cpp\nGRADE::GRADE( const char letter )\n // Reference the object using the keyword 'this'.\n this-&gt;letter = letter;\n // This is Temporal Cohesion\n this-&gt;numeric = grade_numeric( letter );\nint GRADE::grade_numeric( const char letter )\n if ( ( letter == 'A' || letter == 'a' ) )\n return 4;\n else\n if ( ( letter == 'B' || letter == 'b' ) )\n return 3;\n else\n if ( ( letter == 'C' || letter == 'c' ) )\n return 2;\n else\n if ( ( letter == 'D' || letter == 'd' ) )\n return 1;\n else\n if ( ( letter == 'F' || letter == 'f' ) )\n return 0;\n else\n return -1;\nHere is a C++ \"header file\" for the \"PERSON class\" in a simple school application:\n// person.h\nclass PERSON {\npublic:\n PERSON ( const char *name );\n const char *name;\nHere is a C++ \"source code\" for the \"PERSON class\" in a simple school application:\n// person.cpp\nPERSON::PERSON ( const char *name )\n this-&gt;name = name;\nHere is a C++ \"header file\" for the \"STUDENT class\" in a simple school application:\n// student.h\n// A STUDENT is a subset of PERSON.\nclass STUDENT : public PERSON{\npublic:\n STUDENT ( const char *name );\n GRADE *grade;\nHere is a C++ \"source code\" for the \"STUDENT class\" in a simple school application:\n// student.cpp\nSTUDENT::STUDENT ( const char *name ):\n // Execute the constructor of the PERSON superclass.\n PERSON( name )\n // Nothing else to do.\nHere is a driver program for demonstration:\n// student_dvr.cpp\nint main( void )\n STUDENT *student = new STUDENT( \"The Student\" );\n student-&gt;grade = new GRADE( 'a' );\n std::cout \n // Notice student inherits PERSON's name\n \u00ab student-&gt;name\n \u00ab \": Numeric grade = \"\n \u00ab student-&gt;grade-&gt;numeric\n \u00ab \"\\n\";\n return 0;\nHere is a &lt;a href=\"makefile\"&gt;makefile&lt;/a&gt; to compile everything:\nall: student_dvr\nclean:\n rm student_dvr *.o\nstudent_dvr: student_dvr.cpp grade.o student.o person.o\n c++ student_dvr.cpp grade.o student.o person.o -o student_dvr\ngrade.o: grade.cpp grade.h\n c++ -c grade.cpp\nstudent.o: student.cpp student.h\n c++ -c student.cpp\nperson.o: person.cpp person.h\n c++ -c person.cpp\nDeclarative languages.\n\"Imperative languages\" have one major criticism: assigning an expression to a \"non-local\" variable may produce an unintended &lt;a href=\"Side%20effect%20%28computer%20science%29\"&gt;side effect&lt;/a&gt;. &lt;a href=\"Declarative%20programming\"&gt;Declarative languages&lt;/a&gt; generally omit the assignment statement and the control flow. They describe \"what\" computation should be performed and not \"how\" to compute it. Two broad categories of declarative languages are &lt;a href=\"functional%20language\"&gt;functional language&lt;/a&gt;s and &lt;a href=\"Logic%20programming\"&gt;logical languages&lt;/a&gt;.\nThe principle behind a \"functional language\" is to use &lt;a href=\"lambda%20calculus\"&gt;lambda calculus&lt;/a&gt; as a guide for a well defined &lt;a href=\"Semantics%20%28computer%20science%29\"&gt;semantic&lt;/a&gt;. In mathematics, a function is a rule that maps elements from an \"expression\" to a range of \"values\". Consider the function:\ncodice_16\nThe \"expression\" codice_17 is mapped by the function codice_18 to a range of \"values\". One \"value\" happens to be 20. This occurs when x is 2. So, the application of the function is mathematically written as:\ncodice_19\nA \"functional language\" compiler will not store this value in a variable. Instead, it will \"push\" the value onto the computer's &lt;a href=\"Call%20stack\"&gt;stack&lt;/a&gt; before setting the &lt;a href=\"program%20counter\"&gt;program counter&lt;/a&gt; back to the calling function. The calling function will then \"pop\" the value from the stack.\n\"Imperative languages\" do support functions. Therefore, \"functional programming\" can be achieved in an imperative language, if the programmer uses discipline. However, \"functional languages\" force this discipline onto the programmer through its syntax. Functional languages have a syntax tailored to emphasize the \"what\".\nA functional program is developed with a set of primitive functions followed by a single driver function. Consider the &lt;a href=\"Snippet%20%28programming%29\"&gt;snippet&lt;/a&gt;:\ncodice_20\ncodice_21\ncodice_22\ncodice_9\nThe primitives are codice_25 and codice_26. The driver function is codice_27. Executing:\ncodice_28 will output 6.\n\"Functional languages\" are used in &lt;a href=\"computer%20science\"&gt;computer science&lt;/a&gt; research to explore new language features. Moreover, their lack of side-effects have made them popular in &lt;a href=\"Parallel%20computing\"&gt;parallel programming&lt;/a&gt; and &lt;a href=\"Concurrent%20computing\"&gt;concurrent programming&lt;/a&gt;. However, application developers prefer the &lt;a href=\"object-oriented%20programming\"&gt;object-oriented features&lt;/a&gt; of \"imperative languages\".\nLisp.\n&lt;a href=\"Lisp%20%28programming%20language%29\"&gt;Lisp&lt;/a&gt; (1958) stands for \"LISt Processor.\" It is tailored to process &lt;a href=\"List%20%28abstract%20data%20type%29\"&gt;lists&lt;/a&gt;. A full structure of the data is formed by building lists of lists. In memory, a &lt;a href=\"Tree%20%28data%20structure%29\"&gt;tree data structure&lt;/a&gt; is built. Internally, the tree structure lends nicely for &lt;a href=\"Recursion%20%28computer%20science%29\"&gt;recursive&lt;/a&gt; functions. The syntax to build a tree is to enclose the space-separated &lt;a href=\"Element%20%28mathematics%29\"&gt;elements&lt;/a&gt; within parenthesis. The following is a list of three elements. The first two elements are themselves lists of two elements:\ncodice_29\nLisp has functions to extract and reconstruct elements. The function codice_30 returns a list containing the first element in the list. The function codice_31 returns a list containing everything but the first element. The function codice_32 returns a list that is the concatenation of other lists. Therefore, the following expression will return the list codice_33:\ncodice_34\nOne drawback of Lisp is when many functions are nested, the parentheses may look confusing. Modern Lisp &lt;a href=\"Integrated%20development%20environment\"&gt;environments&lt;/a&gt; help ensure parenthesis match. As an aside, Lisp does support the \"imperative language\" operations of the assignment statement and goto loops. Also, \"Lisp\" is not concerned with the &lt;a href=\"data%20type\"&gt;datatype&lt;/a&gt; of the elements at compile time. Instead, it assigns the datatypes at runtime. This may lead to programming errors not being detected early in the development process.\nWriting large, reliable, and readable Lisp programs requires forethought. If properly planned, the program may be much shorter than an equivalent \"imperative language\" program. \"Lisp\" is widely used in &lt;a href=\"artificial%20intelligence\"&gt;artificial intelligence&lt;/a&gt;. However, its usage has been accepted only because it has \"imperative language\" operations, making unintended side-effects possible.\nML.\n&lt;a href=\"ML%20%28programming%20language%29\"&gt;ML&lt;/a&gt; (1973) stands for \"Meta Language.\" ML checks to make sure only data of the same type are compared with one another. For example, this function has one input parameter (an integer) and returns an integer:\ncodice_35\n\"ML\" is not parenthesis-eccentric like \"Lisp\". The following is an application of codice_18:\ncodice_37\nIt returns \"20 : int\". (Both the results and the datatype are returned.)\nLike \"Lisp\", \"ML\" is tailored to process lists. Unlike \"Lisp\", each element is the same datatype.\nProlog.\n&lt;a href=\"Prolog\"&gt;Prolog&lt;/a&gt; (1972) stands for \"PROgramming in LOgic.\" It was designed to process &lt;a href=\"natural%20language\"&gt;natural language&lt;/a&gt;s. The building blocks of a Prolog program are \"&lt;a href=\"Object%20%28philosophy%29\"&gt;objects&lt;/a&gt;\" and their \"relationships\" to other objects. \"Objects\" are built by stating true \"facts\" about them.\n&lt;a href=\"Set%20%28mathematics%29\"&gt;Set theory&lt;/a&gt; \"facts\" are formed by assigning objects to sets. The syntax is codice_38\n&lt;a href=\"Adjective\"&gt;Adjective&lt;/a&gt; \"facts\" are formed using codice_43\n\"Relationships\" are formed using multiple items inside the parentheses. In our example we have codice_46 and codice_47.\nAfter all the facts and relationships are entered, then a question can be asked:\nProlog's usage has expanded to become a goal-oriented language. In a goal-oriented application, the goal is defined by providing a list of subgoals. Then each subgoal is defined by further providing a list of its subgoals, etc. If a path of subgoals fails to find a solution, then that subgoal is &lt;a href=\"backtracking\"&gt;backtracked&lt;/a&gt; and another path is systematically attempted. Practical applications include solving the &lt;a href=\"shortest%20path%20problem\"&gt;shortest path problem&lt;/a&gt; and producing &lt;a href=\"Family%20tree\"&gt;family trees&lt;/a&gt;.\nProgram modules.\n&lt;a href=\"Modular%20programming\"&gt;Modular programming&lt;/a&gt; is a technique to refine \"imperative language\" programs to mitigate &lt;a href=\"software%20aging\"&gt;software aging&lt;/a&gt;. A \"program module\" is a sequence of statements that are bounded within a &lt;a href=\"Block%20%28programming%29\"&gt;block&lt;/a&gt; and together identified by a name. Modules have a \"function\", \"context\", and \"logic\":\nThe module's name should be derived first by its \"function\", then by its \"context\". Its \"logic\" should not be part of the name. For example, codice_51 or codice_52 are appropriate module names. However, codice_53 is not.\nThe degree of interaction \"within\" a module is its level of &lt;a href=\"Cohesion%20%28computer%20science%29\"&gt;cohesion&lt;/a&gt;. \"Cohesion\" is a judgement of the relationship between a module's name and its \"function\". The degree of interaction \"between\" modules is the level of &lt;a href=\"Coupling%20%28computer%20science%29\"&gt;coupling&lt;/a&gt;. \"Coupling\" is a judgement of the relationship between a module's \"context\" and the elements being performed upon.\nCohesion.\nThe levels of cohesion from worst to best are:\nCoupling.\nThe levels of coupling from worst to best are:\nData flow analysis.\n\"Data flow analysis\" is a design method used to achieve modules of \"functional cohesion\" and \"data coupling\". The input to the method is a &lt;a href=\"data-flow%20diagram\"&gt;data-flow diagram&lt;/a&gt;. A data-flow diagram is a set of ovals representing modules. Each module's name is displayed inside its oval. Modules may be at the executable level or the function level.\nThe diagram also has arrows connecting modules to each other. Arrows pointing into modules represent a set of inputs. Each module should have only one arrow pointing out from it to represent its single output object. (Optionally, an additional exception arrow points out.) A &lt;a href=\"Daisy%20chain%20%28electrical%20engineering%29\"&gt;daisy chain&lt;/a&gt; of ovals will convey an entire &lt;a href=\"algorithm\"&gt;algorithm&lt;/a&gt;. The input modules should start the diagram. The input modules should connect to the transform modules. The transform modules should connect to the output modules.\nObject-oriented programming.\n&lt;a href=\"Object-oriented%20programming\"&gt;Object-oriented programming&lt;/a&gt; need not be confined to an \"object-oriented language\". \"Object-oriented programming\" is executing \"operations\" on \"objects\". In object-oriented languages, classes are objects. In non-object-oriented languages, &lt;a href=\"data%20structure\"&gt;data structure&lt;/a&gt;s (which are also known as &lt;a href=\"Record%20%28computer%20science%29\"&gt;records&lt;/a&gt;) may also be objects. To turn a data structure into an object, operations need to be written specifically for the structure. The resulting structure is called an \"abstract datatype\". However, &lt;a href=\"Inheritance%20%28object-oriented%20programming%29\"&gt;inheritance&lt;/a&gt; will be missing. Nonetheless, this shortcoming can be overcome.\nHere is a &lt;a href=\"C%20programming%20language\"&gt;C programming language&lt;/a&gt; \"header file\" for the \"GRADE abstract datatype\" in a simple school application:\n/* grade.h */\n/* Used to allow multiple source files to include */\n/* this header file without duplication errors. */\ntypedef struct\n char letter;\n} GRADE;\n/* Constructor */\nGRADE *grade_new( char letter );\nint grade_numeric( char letter );\nThe codice_62 function performs the same algorithm as the C++ &lt;a href=\"Constructor%20%28object-oriented%20programming%29\"&gt;constructor&lt;/a&gt; operation.\nHere is a C programming language source file for the \"GRADE abstract datatype\" in a simple school application:\n/* grade.c */\nGRADE *grade_new( char letter )\n GRADE *grade;\n /* Allocate heap memory */\n if ( ! ( grade = calloc( 1, sizeof( GRADE ) ) ) )\n fprintf(stderr,\n \"ERROR in %s/%s/%d: calloc() returned empty.\\n\",\n __FILE__,\n __FUNCTION__,\n __LINE__ );\n exit( 1 );\n grade-&gt;letter = letter;\n return grade;\nint grade_numeric( char letter )\n if ( ( letter == 'A' || letter == 'a' ) )\n return 4;\n else\n if ( ( letter == 'B' || letter == 'b' ) )\n return 3;\n else\n if ( ( letter == 'C' || letter == 'c' ) )\n return 2;\n else\n if ( ( letter == 'D' || letter == 'd' ) )\n return 1;\n else\n if ( ( letter == 'F' || letter == 'f' ) )\n return 0;\n else\n return -1;\nIn the constructor, the function codice_63 is used instead of codice_4 because each memory cell will be set to zero.\nHere is a C programming language \"header file\" for the \"PERSON abstract datatype\" in a simple school application:\n/* person.h */\ntypedef struct\n char *name;\n} PERSON;\n/* Constructor */\nPERSON *person_new( char *name );\nHere is a C programming language \"source code\" for the \"PERSON abstract datatype\" in a simple school application:\n/* person.c */\nPERSON *person_new( char *name )\n PERSON *person;\n if ( ! ( person = calloc( 1, sizeof( PERSON ) ) ) )\n fprintf(stderr,\n \"ERROR in %s/%s/%d: calloc() returned empty.\\n\",\n __FILE__,\n __FUNCTION__,\n __LINE__ );\n exit( 1 );\n person-&gt;name = name;\n return person;\nHere is a C programming language \"header file\" for the \"STUDENT abstract datatype\" in a simple school application:\n/* student.h */\ntypedef struct\n /* A STUDENT is a subset of PERSON. */\n PERSON *person;\n GRADE *grade;\n} STUDENT;\n/* Constructor */\nSTUDENT *student_new( char *name );\nHere is a C programming language \"source code\" for the \"STUDENT abstract datatype\" in a simple school application:\n/* student.c */\nSTUDENT *student_new( char *name )\n STUDENT *student;\n if ( ! ( student = calloc( 1, sizeof( STUDENT ) ) ) )\n fprintf(stderr,\n \"ERROR in %s/%s/%d: calloc() returned empty.\\n\",\n __FILE__,\n __FUNCTION__,\n __LINE__ );\n exit( 1 );\n /* Execute the constructor of the PERSON superclass. */\n student-&gt;person = person_new( name );\n return student;\nHere is a driver program for demonstration:\n/* student_dvr.c */\nint main( void )\n STUDENT *student = student_new( \"The Student\" );\n student-&gt;grade = grade_new( 'a' );\n printf( \"%s: Numeric grade = %d\\n\",\n /* Whereas a subset exists, inheritance does not. */\n student-&gt;person-&gt;name,\n /* Functional programming is executing functions just-in-time (JIT) */\n grade_numeric( student-&gt;grade-&gt;letter ) );\n return 0;\nHere is a &lt;a href=\"makefile\"&gt;makefile&lt;/a&gt; to compile everything:\nall: student_dvr\nclean:\n rm student_dvr *.o\nstudent_dvr: student_dvr.c grade.o student.o person.o\n gcc student_dvr.c grade.o student.o person.o -o student_dvr\ngrade.o: grade.c grade.h\n gcc -c grade.c\nstudent.o: student.c student.h\n gcc -c student.c\nperson.o: person.c person.h\n gcc -c person.c\nThe formal strategy to build object-oriented objects is to:\nFor example:\nFunctional categories.\nComputer programs may be categorized along functional lines. The main functional categories are &lt;a href=\"application%20software\"&gt;application software&lt;/a&gt; and &lt;a href=\"system%20software\"&gt;system software&lt;/a&gt;. System software includes the &lt;a href=\"operating%20system\"&gt;operating system&lt;/a&gt; which couples &lt;a href=\"computer%20hardware\"&gt;computer hardware&lt;/a&gt; with application software. The purpose of the operating system is to provide an environment where application software executes in a convenient and efficient manner. In addition to the operating system, system software includes &lt;a href=\"Firmware\"&gt;embedded programs&lt;/a&gt;, &lt;a href=\"Booting\"&gt;boot programs&lt;/a&gt;, and &lt;a href=\"Microcode\"&gt;micro programs&lt;/a&gt;. Application software designed for &lt;a href=\"end%20user\"&gt;end user&lt;/a&gt;s have a &lt;a href=\"Interface%20%28computing%29\"&gt;user interface&lt;/a&gt;. Application software not designed for end users includes &lt;a href=\"middleware\"&gt;middleware&lt;/a&gt;, which couples one application with another. Both system software and application software execute &lt;a href=\"Utility%20software\"&gt;utility programs&lt;/a&gt;.\nApplication software.\nApplication software is the key to unlocking the potential of the computer system. &lt;a href=\"Enterprise%20software\"&gt;Enterprise application software&lt;/a&gt; bundles accounting, personnel, customer, and vendor applications. Examples include &lt;a href=\"enterprise%20resource%20planning\"&gt;enterprise resource planning&lt;/a&gt;, &lt;a href=\"customer%20relationship%20management\"&gt;customer relationship management&lt;/a&gt;, and &lt;a href=\"supply%20chain%20management%20software\"&gt;supply chain management software&lt;/a&gt;. \nEnterprise applications may be developed in-house as a one-of-a-kind &lt;a href=\"proprietary%20software\"&gt;proprietary software&lt;/a&gt;. Alternatively, they may be purchased as &lt;a href=\"Commercial%20off-the-shelf\"&gt;off-the-shelf software&lt;/a&gt;. Purchased software may be modified to provide &lt;a href=\"custom%20software\"&gt;custom software&lt;/a&gt;. If the application is customized, then either the company's resources are used or the resources are outsourced. Outsourced software development may be from the original software vendor or a third-party developer.\nThe advantages of proprietary software are features and reports may be exact to specification. Management may also be involved in the development process and offer a level of control. Management may decide to counteract a competitor's new initiative or implement a customer or vendor requirement. A merger or acquisition will necessitate enterprise software changes. The disadvantages of proprietary software are the time and resource costs may be extensive. Furthermore, risks concerning features and performance may be looming.\nThe advantages of off-the-shelf software are its identifiable upfront costs, the basic needs should be fulfilled, and its performance and reliability have a track record. The disadvantages of off-the-shelf software are it may have unnecessary features that confuse end users, it may lack features the enterprise needs, and the data flow may not match the enterprise's work processes.\nOne approach to economically obtaining a customized enterprise application is through an &lt;a href=\"application%20service%20provider\"&gt;application service provider&lt;/a&gt;. Specialty companies provide the hardware, custom software, and end-user support. They may speed development of new applications because they possess skilled information system staff. The biggest advantage is it frees in-house resources from staffing and managing complex computer projects. Many application service providers target small, fast-growing companies with limited information system resources. On the other hand, larger companies with major systems will likely have their technical infrastructure in place. One risk is having to trust an external organization with sensitive information. Another risk is having to trust the provider's infrastructure reliability.\nOperating system.\nAn &lt;a href=\"operating%20system\"&gt;operating system&lt;/a&gt; is the low-level software that supports a computer's basic functions, such as &lt;a href=\"Scheduling%20%28computing%29\"&gt;scheduling tasks&lt;/a&gt; and controlling &lt;a href=\"Peripheral\"&gt;peripherals&lt;/a&gt;.\nIn the 1950s, the programmer, who was also the operator, would write a program and run it. After the program finished executing, the output may have been printed, or it may have been punched onto paper tape or cards for later processing. More often than not the program did not work. The programmer then looked at the console lights and fiddled with the console switches. If less fortunate, a memory printout was made for further study. In the 1960s, programmers reduced the amount of wasted time by automating the operator's job. A program called an \"operating system\" was kept in the computer at all times.\nThe term \"operating system\" may refer to two levels of software. The operating system may refer to the &lt;a href=\"Kernel%20%28operating%20system%29\"&gt;kernel program&lt;/a&gt; that manages the &lt;a href=\"Process%20%28computing%29\"&gt;processes&lt;/a&gt;, &lt;a href=\"Computer%20memory\"&gt;memory&lt;/a&gt;, and &lt;a href=\"Peripheral\"&gt;devices&lt;/a&gt;. More broadly, the operating system may refer to the entire package of the central software. The package includes a kernel program, &lt;a href=\"Command-line%20interface\"&gt;command-line interpreter&lt;/a&gt;, &lt;a href=\"graphical%20user%20interface\"&gt;graphical user interface&lt;/a&gt;, &lt;a href=\"Utility%20software\"&gt;utility programs&lt;/a&gt;, and &lt;a href=\"Source-code%20editor\"&gt;editor&lt;/a&gt;.\nKernel Program.\nThe kernel's main purpose is to manage the limited resources of a computer:\nOriginally, operating systems were programmed in &lt;a href=\"assembly%20language\"&gt;assembly&lt;/a&gt;; however, modern operating systems are typically written in higher level languages like &lt;a href=\"C%20%28programming%20language%29\"&gt;C&lt;/a&gt;, &lt;a href=\"C%2B%2B\"&gt;C++&lt;/a&gt;, &lt;a href=\"Objective-C\"&gt;Objective-C&lt;/a&gt;, and &lt;a href=\"Swift%20%28programming%20language%29\"&gt;Swift&lt;/a&gt;.\nInterrupts.\nInterrupts cause the &lt;a href=\"central%20processing%20unit\"&gt;central processing unit&lt;/a&gt; (CPU) to have a &lt;a href=\"control%20flow\"&gt;control flow&lt;/a&gt; change away from the currently running &lt;a href=\"Process%20%28computing%29\"&gt;process&lt;/a&gt;. &lt;a href=\"Input/Output\"&gt;Input/Output&lt;/a&gt; (I/O) &lt;a href=\"Peripheral\"&gt;devices&lt;/a&gt; are slower than the CPU's &lt;a href=\"clock%20signal\"&gt;clock signal&lt;/a&gt;. Therefore, it would slow down the computer if the CPU had to wait for each I/O to finish. Instead, a computer may implement direct memory access (DMA) I/O.\nIf a \"computer program\" in a computer with a direct memory access chip executes a &lt;a href=\"system%20call\"&gt;system call&lt;/a&gt; to perform a DMA I/O write operation, then the system call will execute the following instructions:\nWhile the writing takes place, the operating system will context switch to other processes as normal. When the device finishes writing, the device will \"interrupt\" the currently running process by \"asserting\" an &lt;a href=\"Interrupt%20request%20%28PC%20architecture%29\"&gt;interrupt request&lt;/a&gt;. The device will also place an integer onto the device's &lt;a href=\"Bus%20%28computing%29\"&gt;data bus&lt;/a&gt;. Upon accepting the interrupt request, the CPU will:\nThe operating system will then:\nWhen the writing process has its &lt;a href=\"Preemption%20%28computing%29%23time%20slice\"&gt;time slice&lt;/a&gt; expired, the CPU will:\nThe interrupted process will then resume its time slice.\nUtility program.\nA &lt;a href=\"Utility%20software\"&gt;utility program&lt;/a&gt; is designed to aid system administration and software execution. Operating systems execute hardware utility programs to check the status of disk drives, memory, speakers, and printers. A utility program may optimize the placement of a file on a crowded disk. System utility programs monitor hardware and network performance. When a metric is outside an acceptable range, a trigger alert is generated.\nUtility programs include compression programs so data files are stored on less disk space. Compressed programs also save time when data files are transmitted over the network. Utility programs can sort and merge data sets. Utility programs detect &lt;a href=\"Computer%20virus\"&gt;computer viruses&lt;/a&gt;.\nBoot program.\nA &lt;a href=\"stored-program%20computer\"&gt;stored-program computer&lt;/a&gt; requires an initial \"boot program\" stored in its &lt;a href=\"read-only%20memory\"&gt;read-only memory&lt;/a&gt; to &lt;a href=\"booting\"&gt;boot&lt;/a&gt;. It should identify and initialize all aspects of the system, from &lt;a href=\"processor%20register\"&gt;processor register&lt;/a&gt;s to &lt;a href=\"device%20driver\"&gt;device controllers&lt;/a&gt; to &lt;a href=\"volatile%20memory\"&gt;memory&lt;/a&gt; contents. Following the initialization process, the boot program loads the &lt;a href=\"operating%20system\"&gt;operating system&lt;/a&gt; and sets the &lt;a href=\"program%20counter\"&gt;program counter&lt;/a&gt; to begin normal operations.\nEmbedded program.\nIndependent of the host computer, a &lt;a href=\"Peripheral\"&gt;hardware device&lt;/a&gt; might have embedded &lt;a href=\"firmware\"&gt;firmware&lt;/a&gt; to control its operation. Firmware is used when the computer program is rarely or never expected to change, or when it must not be lost when the power is off.\nOn a larger scale, an embedded &lt;a href=\"microcontroller\"&gt;microcontroller&lt;/a&gt; is used to control part of a larger system. Examples include aircraft components and life support systems. Applications running on these systems are large and complex. Moreover, they run in &lt;a href=\"Real-time%20computing\"&gt;real-time&lt;/a&gt; and must be &lt;a href=\"Robustness%20%28computer%20science%29\"&gt;robust&lt;/a&gt;. The &lt;a href=\"United%20States%20Department%20of%20Defense\"&gt;United States Department of Defense&lt;/a&gt; contracted with &lt;a href=\"Groupe%20Bull\"&gt;CII Honeywell Bull&lt;/a&gt; to develop &lt;a href=\"Ada%20%28programming%20language%29\"&gt;Ada&lt;/a&gt; (1983) as a real-time programming language.\nCentral to real-time systems is a &lt;a href=\"Daemon%20%28computing%29\"&gt;task facility&lt;/a&gt; to permit &lt;a href=\"Parallel%20computing\"&gt;parallel processing&lt;/a&gt;. Also important are &lt;a href=\"Interrupt\"&gt;interrupt controls&lt;/a&gt;.\nMicrocode program.\nA &lt;a href=\"Microcode\"&gt;microcode program&lt;/a&gt; is the bottom-level interpreter that controls the &lt;a href=\"Datapath\"&gt;data path&lt;/a&gt; of software driven computers.\n(Advances in hardware have migrated these operations to &lt;a href=\"Control_unit%23Hardwired_control_unit\"&gt;hardware execution circuits&lt;/a&gt;.) Microcode instructions allow the programmer to more easily implement the &lt;a href=\"Logic%20level\"&gt;digital logic level&lt;/a&gt;\u2014the computer's real hardware. The digital logic level is the boundary between &lt;a href=\"computer%20science\"&gt;computer science&lt;/a&gt; and &lt;a href=\"computer%20engineering\"&gt;computer engineering&lt;/a&gt;.\nA &lt;a href=\"Field-effect%20transistor%23Gate\"&gt;gate&lt;/a&gt; is a tiny &lt;a href=\"transistor\"&gt;transistor&lt;/a&gt; that can return one of two signals: on or off.\nThese five gates form the building blocks of &lt;a href=\"Boolean%20algebra\"&gt;binary algebra&lt;/a&gt;\u2014the digital logic functions of the computer.\nMicrocode instructions are &lt;a href=\"Assembly%20language%23Mnemonics\"&gt;mnemonics&lt;/a&gt; programmers may use to execute digital logic functions instead of forming them in binary algebra. They are stored in a &lt;a href=\"central%20processing%20unit\"&gt;central processing unit's&lt;/a&gt; (CPU) &lt;a href=\"control%20store\"&gt;control store&lt;/a&gt;.\nThese hardware-level instructions move data throughout the &lt;a href=\"Datapath\"&gt;data path&lt;/a&gt;.\nMicrocode instructions move data between a CPU's &lt;a href=\"Processor%20register\"&gt;registers&lt;/a&gt; and throughout the &lt;a href=\"motherboard\"&gt;motherboard&lt;/a&gt;. The micro-instruction cycle begins when the &lt;a href=\"microsequencer\"&gt;microsequencer&lt;/a&gt; uses its microprogram counter to \"fetch\" the next &lt;a href=\"Machine%20code\"&gt;machine instruction&lt;/a&gt; from &lt;a href=\"random%20access%20memory\"&gt;random access memory&lt;/a&gt;. The next step is to \"decode\" the machine instruction by selecting the proper output line to the hardware module.\nThe final step is to \"execute\" the instruction using the hardware module's set of gates.\nInstructions to perform arithmetic are passed through an &lt;a href=\"arithmetic%20logic%20unit\"&gt;arithmetic logic unit&lt;/a&gt; (ALU). The ALU has circuits to perform elementary operations to add, shift, and compare integers. By combining and looping the elementary operations through the ALU, the CPU performs its complex arithmetic.\nMicrocode instructions move data between the CPU and the &lt;a href=\"memory%20controller\"&gt;memory controller&lt;/a&gt;. Memory controller microcode instructions manipulate two &lt;a href=\"Processor%20register\"&gt;registers&lt;/a&gt;. The &lt;a href=\"memory%20address%20register\"&gt;memory address register&lt;/a&gt; is used to access each memory cell's address. The &lt;a href=\"Memory%20buffer%20register\"&gt;memory data register&lt;/a&gt; is used to set and read each cell's contents.\nMicrocode instructions move data between the CPU and the many &lt;a href=\"Bus%20%28computing%29\"&gt;computer buses&lt;/a&gt;. The &lt;a href=\"Disk%20controller\"&gt;disk controller bus&lt;/a&gt; writes to and reads from &lt;a href=\"Hard%20disk%20drive\"&gt;hard disk drives&lt;/a&gt;. Data is also moved between the CPU and other functional units via the &lt;a href=\"PCI%20Express\"&gt;peripheral component interconnect express bus.&lt;/a&gt;"
}