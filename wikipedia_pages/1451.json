{
    "id": "1451",
    "revid": "985645",
    "url": "https://en.wikipedia.org/wiki?curid=1451",
    "title": "APL (programming language)",
    "text": "APL (named after the book \"A Programming Language\") is a &lt;a href=\"programming%20language\"&gt;programming language&lt;/a&gt; developed in the 1960s by &lt;a href=\"Kenneth%20E.%20Iverson\"&gt;Kenneth E. Iverson&lt;/a&gt;. Its central datatype is the &lt;a href=\"Array%20data%20type%23Multi-dimensional%20arrays\"&gt;multidimensional array&lt;/a&gt;. It uses a large range of &lt;a href=\"APL%20syntax%20and%20symbols\"&gt;special graphic symbols&lt;/a&gt; to represent most functions and operators, leading to very concise code. It has been an important influence on the development of concept modeling, &lt;a href=\"spreadsheet\"&gt;spreadsheet&lt;/a&gt;s, &lt;a href=\"functional%20programming\"&gt;functional programming&lt;/a&gt;, and computer math packages. It has also inspired several other programming languages.\nHistory.\nMathematical notation.\nA &lt;a href=\"mathematical%20notation\"&gt;mathematical notation&lt;/a&gt; for manipulating arrays was developed by &lt;a href=\"Kenneth%20E.%20Iverson\"&gt;Kenneth E. Iverson&lt;/a&gt;, starting in 1957 at &lt;a href=\"Harvard%20University\"&gt;Harvard University&lt;/a&gt;. In 1960, he began work for &lt;a href=\"IBM\"&gt;IBM&lt;/a&gt; where he developed this notation with &lt;a href=\"Adin%20Falkoff\"&gt;Adin Falkoff&lt;/a&gt; and published it in his book \"A Programming Language\" in 1962. The preface states its premise:\nThis notation was used inside IBM for short research reports on computer systems, such as the &lt;a href=\"Burroughs%20B5000\"&gt;Burroughs B5000&lt;/a&gt; and its stack mechanism when &lt;a href=\"stack%20machine\"&gt;stack machine&lt;/a&gt;s versus &lt;a href=\"register%20machine\"&gt;register machine&lt;/a&gt;s were being evaluated by IBM for upcoming computers.\nIverson also used his notation in a draft of the chapter \"A Programming Language\", written for a book he was writing with &lt;a href=\"Fred%20Brooks\"&gt;Fred Brooks&lt;/a&gt;, \"Automatic Data Processing\", which would be published in 1963.\nIn 1979, Iverson received the &lt;a href=\"Turing%20Award\"&gt;Turing Award&lt;/a&gt; for his work on APL.\nDevelopment into a computer programming language.\nAs early as 1962, the first attempt to use the notation to describe a complete computer system happened after Falkoff discussed with William C. Carter his work to standardize the instruction set for the machines that later became the &lt;a href=\"IBM%20System/360\"&gt;IBM System/360&lt;/a&gt; family.\nIn 1963, Herbert Hellerman, working at the IBM Systems Research Institute, implemented a part of the notation on an &lt;a href=\"IBM%201620\"&gt;IBM 1620&lt;/a&gt; computer, and it was used by students in a special high school course on calculating transcendental functions by series summation. Students tested their code in Hellerman's lab. This implementation of a part of the notation was called Personalized Array Translator (PAT).\nIn 1963, Falkoff, Iverson, and &lt;a href=\"Edward%20H.%20Sussenguth%20Jr.\"&gt;Edward H. Sussenguth Jr.&lt;/a&gt;, all working at IBM, used the notation for a formal description of the &lt;a href=\"IBM%20System/360\"&gt;IBM System/360&lt;/a&gt; series machine architecture and functionality, which resulted in a paper published in \"&lt;a href=\"IBM%20Systems%20Journal\"&gt;IBM Systems Journal&lt;/a&gt;\" in 1964. After this was published, the team turned their attention to an implementation of the notation on a computer system. One of the motivations for this focus of implementation was the interest of John L. Lawrence who had new duties with &lt;a href=\"Science%20Research%20Associates\"&gt;Science Research Associates&lt;/a&gt;, an educational company bought by IBM in 1964. Lawrence asked Iverson and his group to help use the language as a tool to develop and use computers in education.\nAfter &lt;a href=\"Lawrence%20M.%20Breed\"&gt;Lawrence M. Breed&lt;/a&gt; and &lt;a href=\"Philip%20S.%20Abrams\"&gt;Philip S. Abrams&lt;/a&gt; of Stanford University joined the team at IBM Research, they continued their prior work on an implementation programmed in &lt;a href=\"FORTRAN%20IV\"&gt;FORTRAN IV&lt;/a&gt; for a part of the notation which had been done for the &lt;a href=\"IBM%207090\"&gt;IBM 7090&lt;/a&gt; computer running on the &lt;a href=\"IBM%207090/94%20IBSYS\"&gt;IBSYS&lt;/a&gt; operating system. This work was finished in late 1965 and later named IVSYS (for Iverson system). The basis of this implementation was described in detail by Abrams in a Stanford University Technical Report, \"An Interpreter for Iverson Notation\" in 1966, the academic aspect of this was formally supervised by &lt;a href=\"Niklaus%20Wirth\"&gt;Niklaus Wirth&lt;/a&gt;. Like Hellerman's PAT system earlier, this implementation did not include the APL character set but used special English reserved words for functions and operators. The system was later adapted for a &lt;a href=\"time-sharing\"&gt;time-sharing&lt;/a&gt; system and, by November 1966, it had been reprogrammed for the &lt;a href=\"IBM%20System/360%20Model%2050\"&gt;IBM System/360 Model 50&lt;/a&gt; computer running in a time-sharing mode and was used internally at IBM.\nHardware.\nA key development in the ability to use APL effectively, before the wide use of cathode ray tube (&lt;a href=\"Computer%20monitor%23Cathode%20ray%20tube\"&gt;CRT&lt;/a&gt;) terminals, was the development of a special &lt;a href=\"IBM%20Selectric%20typewriter\"&gt;IBM Selectric typewriter&lt;/a&gt; interchangeable typing element with all the special APL characters on it. This was used on paper printing terminal workstations using the Selectric typewriter and typing element mechanism, such as the &lt;a href=\"IBM%201050\"&gt;IBM 1050&lt;/a&gt; and &lt;a href=\"IBM%202741\"&gt;IBM 2741&lt;/a&gt; terminal. Keycaps could be placed over the normal keys to show which APL characters would be entered and typed when that key was struck. For the first time, a programmer could type in and see proper APL characters as used in Iverson's notation and not be forced to use awkward English keyword representations of them. Falkoff and Iverson had the special APL Selectric typing elements, 987 and 988, designed in late 1964, although no APL computer system was available to use them. Iverson cited Falkoff as the inspiration for the idea of using an IBM Selectric typing element for the APL character set.\nMany APL symbols, even with the APL characters on the Selectric typing element, still had to be typed in by over-striking two extant element characters. An example is the \"grade up\" character, which had to be made from a \"delta\" (shift-H) and a \"&lt;a href=\"Sheffer%20stroke\"&gt;Sheffer stroke&lt;/a&gt;\" (shift-M). This was necessary because the APL character set was much larger than the 88 characters allowed on the typing element, even when letters were restricted to upper-case (capitals).\nCommercial availability.\nThe first APL interactive login and creation of an APL workspace was in 1966 by Larry Breed using an IBM 1050 terminal at the IBM Mohansic Labs near &lt;a href=\"Thomas%20J.%20Watson%20Research%20Center\"&gt;Thomas J. Watson Research Center&lt;/a&gt;, the home of APL, in &lt;a href=\"Yorktown%20Heights\"&gt;Yorktown Heights&lt;/a&gt;, New York.\nIBM was chiefly responsible for introducing APL to the marketplace. The first publicly available version of APL was released in 1968 for the &lt;a href=\"IBM%201130\"&gt;IBM 1130&lt;/a&gt;. IBM provided \"APL\\1130\" for free but without liability or support. It would run in as little as 8k 16-bit words of memory, and used a dedicated 1 megabyte hard disk.\nAPL gained its foothold on mainframe timesharing systems from the late 1960s through the early 1980s, in part because it would support multiple users on lower-specification systems that had no &lt;a href=\"Memory%20management%20unit\"&gt;dynamic address translation&lt;/a&gt; hardware. Additional improvements in performance for selected &lt;a href=\"IBM%20System/370\"&gt;IBM System/370&lt;/a&gt; mainframe systems included the \"APL Assist Microcode\" in which some support for APL execution was included in the processor's &lt;a href=\"firmware\"&gt;firmware&lt;/a&gt;, as distinct from being implemented entirely by higher-level software. Somewhat later, as suitably performing hardware was finally growing available in the mid- to late-1980s, many users migrated their applications to the personal computer environment.\nEarly IBM APL interpreters for IBM 360 and IBM 370 hardware implemented their own multi-user management instead of relying on the host services, thus they were their own timesharing systems. First introduced for use at IBM in 1966, the \"APL\\360\" system was a multi-user interpreter. The ability to programmatically communicate with the operating system for information and setting interpreter system variables was done through special privileged \"I-beam\" functions, using both &lt;a href=\"Monad%20%28functional%20programming%29\"&gt;monadic&lt;/a&gt; and &lt;a href=\"Dyadics\"&gt;dyadic&lt;/a&gt; operations.\nIn 1973, IBM released \"APL.SV\", which was a continuation of the same product, but which offered &lt;a href=\"shared%20variable\"&gt;shared variable&lt;/a&gt;s as a means to access facilities outside of the APL system, such as operating system files. In the mid-1970s, the IBM mainframe interpreter was even adapted for use on the &lt;a href=\"IBM%205100\"&gt;IBM 5100&lt;/a&gt; desktop computer, which had a small CRT and an APL keyboard, when most other small computers of the time only offered &lt;a href=\"BASIC\"&gt;BASIC&lt;/a&gt;. In the 1980s, the \"VSAPL\" program product enjoyed wide use with &lt;a href=\"Conversational%20Monitor%20System\"&gt;Conversational Monitor System&lt;/a&gt; (CMS), &lt;a href=\"Time%20Sharing%20Option\"&gt;Time Sharing Option&lt;/a&gt; (TSO), &lt;a href=\"VSPC\"&gt;VSPC&lt;/a&gt;, &lt;a href=\"MUSIC/SP\"&gt;MUSIC/SP&lt;/a&gt;, and &lt;a href=\"CICS\"&gt;CICS&lt;/a&gt; users.\nIn 1973\u20131974, Patrick E. Hagerty directed the implementation of the University of Maryland APL interpreter for the 1100 line of the Sperry &lt;a href=\"UNIVAC%201100/2200%20series\"&gt;UNIVAC 1100/2200 series&lt;/a&gt; mainframe computers. At the time, Sperry had nothing. In 1974, student Alan Stebbens was assigned the task of implementing an internal function. Xerox APL was available from June 1975 for Xerox 560 and Sigma 6, 7, and 9 mainframes running &lt;a href=\"Universal%20Time-Sharing%20System%23CP-V\"&gt;CP-V&lt;/a&gt; and for &lt;a href=\"Honeywell%20CP-6\"&gt;Honeywell CP-6&lt;/a&gt;.\nIn the 1960s and 1970s, several timesharing firms arose that sold APL services using modified versions of the IBM APL\\360 interpreter. In North America, the better-known ones were &lt;a href=\"IP%20Sharp%20Associates\"&gt;IP Sharp Associates&lt;/a&gt;, &lt;a href=\"Scientific%20Time%20Sharing%20Corporation\"&gt;Scientific Time Sharing Corporation&lt;/a&gt; (STSC), Time Sharing Resources (TSR), and &lt;a href=\"The%20Computer%20Company\"&gt;The Computer Company&lt;/a&gt; (TCC). CompuServe also entered the market in 1978 with an APL Interpreter based on a modified version of Digital Equipment Corp and Carnegie Mellon's, which ran on DEC's KI and KL 36-bit machines. CompuServe's APL was available both to its commercial market and the consumer information service. With the advent first of less expensive mainframes such as the &lt;a href=\"IBM%204300\"&gt;IBM 4300&lt;/a&gt;, and later the personal computer, by the mid-1980s, the timesharing industry was all but gone.\n\"Sharp APL\" was available from IP Sharp Associates, first as a timesharing service in the 1960s, and later as a program product starting around 1979. \"Sharp APL\" was an advanced APL implementation with many language extensions, such as \"packages\" (the ability to put one or more objects into a single variable), file system, nested arrays, and &lt;a href=\"shared%20variable\"&gt;shared variable&lt;/a&gt;s.\nAPL interpreters were available from other mainframe and mini-computer manufacturers also, notably &lt;a href=\"Burroughs%20Corporation\"&gt;Burroughs&lt;/a&gt;, &lt;a href=\"Control%20Data%20Corporation\"&gt;Control Data Corporation&lt;/a&gt; (CDC), &lt;a href=\"Data%20General\"&gt;Data General&lt;/a&gt;, &lt;a href=\"Digital%20Equipment%20Corporation\"&gt;Digital Equipment Corporation&lt;/a&gt; (DEC), &lt;a href=\"Harris%20Corporation\"&gt;Harris&lt;/a&gt;, &lt;a href=\"Hewlett-Packard\"&gt;Hewlett-Packard&lt;/a&gt; (HP), &lt;a href=\"Siemens\"&gt;Siemens&lt;/a&gt;, &lt;a href=\"Xerox\"&gt;Xerox&lt;/a&gt; and others.\nGarth Foster of &lt;a href=\"Syracuse%20University\"&gt;Syracuse University&lt;/a&gt; sponsored regular meetings of the APL implementers' community at Syracuse's Minnowbrook Conference Center in &lt;a href=\"Blue%20Mountain%20Lake%20%28hamlet%29%2C%20New%20York\"&gt;Blue Mountain Lake, New York&lt;/a&gt;. In later years, Eugene McDonnell organized similar meetings at the &lt;a href=\"Asilomar%20Conference%20Grounds\"&gt;Asilomar Conference Grounds&lt;/a&gt; near &lt;a href=\"Monterey\"&gt;Monterey&lt;/a&gt;, &lt;a href=\"California\"&gt;California&lt;/a&gt;, and at Pajaro Dunes near &lt;a href=\"Watsonville\"&gt;Watsonville&lt;/a&gt;, California. The SIGAPL special interest group of the &lt;a href=\"Association%20for%20Computing%20Machinery\"&gt;Association for Computing Machinery&lt;/a&gt; continues to support the APL community.\nMicrocomputers.\nOn microcomputers, which became available from the mid 1970s onwards, &lt;a href=\"BASIC\"&gt;BASIC&lt;/a&gt; became the dominant programming language. Nevertheless, some microcomputers provided APL instead - the first being the &lt;a href=\"Intel%208008\"&gt;Intel 8008&lt;/a&gt;-based &lt;a href=\"MCM/70\"&gt;MCM/70&lt;/a&gt; which was released in 1974 and which was primarily used in education. Another machine of this time was the &lt;a href=\"VideoBrain%20Family%20Computer\"&gt;VideoBrain Family Computer&lt;/a&gt;, released in 1977, which was supplied with its dialect of APL called APL/S.\nThe &lt;a href=\"Commodore%20SuperPET\"&gt;Commodore SuperPET&lt;/a&gt;, introduced in 1981, included an APL interpreter developed by the &lt;a href=\"University%20of%20Waterloo\"&gt;University of Waterloo&lt;/a&gt;.\nIn 1976, Bill Gates claimed in his &lt;a href=\"Open%20Letter%20to%20Hobbyists\"&gt;Open Letter to Hobbyists&lt;/a&gt; that &lt;a href=\"Microsoft%20Corporation\"&gt;Microsoft Corporation&lt;/a&gt; was implementing APL for the &lt;a href=\"Intel%208080\"&gt;Intel 8080&lt;/a&gt; and &lt;a href=\"Motorola%206800\"&gt;Motorola 6800&lt;/a&gt; but had \"very little incentive to make [it] available to hobbyists\" because of &lt;a href=\"software%20piracy\"&gt;software piracy&lt;/a&gt;. It was never released.\nAPL2.\nStarting in the early 1980s, IBM APL development, under the leadership of &lt;a href=\"Jim%20Brown%20%28computer%20scientist%29\"&gt;Jim Brown&lt;/a&gt;, implemented a new version of the APL language that contained as its primary enhancement the concept of \"nested arrays\", where an array can contain other arrays, and new language features which facilitated integrating nested arrays into program workflow. Ken Iverson, no longer in control of the development of the APL language, left IBM and joined &lt;a href=\"I.%20P.%20Sharp%20Associates\"&gt;I. P. Sharp Associates&lt;/a&gt;, where one of his major contributions was directing the evolution of Sharp APL to be more in accord with his vision. APL2 was first released for &lt;a href=\"Conversational%20Monitor%20System\"&gt;CMS&lt;/a&gt; and &lt;a href=\"Time%20Sharing%20Option\"&gt;TSO&lt;/a&gt; in 1984. The APL2 Workstation edition (Windows, &lt;a href=\"OS/2\"&gt;OS/2&lt;/a&gt;, &lt;a href=\"IBM%20AIX\"&gt;AIX&lt;/a&gt;, &lt;a href=\"Linux\"&gt;Linux&lt;/a&gt;, and &lt;a href=\"Solaris%20%28operating%20system%29\"&gt;Solaris&lt;/a&gt;) followed later.\nAs other vendors were busy developing APL interpreters for new hardware, notably &lt;a href=\"Unix\"&gt;Unix&lt;/a&gt;-based &lt;a href=\"microcomputer\"&gt;microcomputer&lt;/a&gt;s, APL2 was almost always the standard chosen for new APL interpreter developments. Even today, most APL vendors or their users cite APL2 compatibility, as a selling point for those products. IBM cites its use for problem solving, system design, prototyping, engineering and scientific computations, expert systems, for teaching mathematics and other subjects, visualization and database access.\nModern implementations.\nVarious implementations of APL by APLX, Dyalog, et al., include extensions for &lt;a href=\"object-oriented%20programming\"&gt;object-oriented programming&lt;/a&gt;, support for &lt;a href=\".NET%20Framework\"&gt;.NET Framework&lt;/a&gt;, XML-array conversion primitives, graphing, operating system interfaces, and &lt;a href=\"lambda%20calculus\"&gt;lambda calculus&lt;/a&gt; expressions.\nDerivative languages.\nAPL has formed the basis of, or influenced, the following languages:\nLanguage characteristics.\nCharacter set.\nAPL has been criticized and praised for its choice of a unique, non-standard character set. Some who learn it become ardent adherents. In the 1960s and 1970s, few terminal devices or even displays could reproduce the APL character set. The most popular ones employed the &lt;a href=\"IBM%20Selectric\"&gt;IBM Selectric&lt;/a&gt; print mechanism used with a special APL type element. One of the early APL &lt;a href=\"Computer%20terminal\"&gt;line terminals&lt;/a&gt; (line-mode operation only, \"not\" full screen) was the Texas Instruments TI Model 745 (circa 1977) with the full APL character set which featured &lt;a href=\"Duplex%20%28telecommunications%29\"&gt;half and full duplex&lt;/a&gt; &lt;a href=\"telecommunication\"&gt;telecommunication&lt;/a&gt;s modes, for interacting with an APL &lt;a href=\"time-sharing\"&gt;time-sharing&lt;/a&gt; service or remote mainframe to run a remote computer job, &lt;a href=\"Remote%20job%20entry\"&gt;called an RJE&lt;/a&gt;.\nOver time, with the universal use of high-quality graphic displays, printing devices and &lt;a href=\"Unicode\"&gt;Unicode&lt;/a&gt; support, the APL character font problem has largely been eliminated. However, entering APL characters requires the use of &lt;a href=\"input%20method%20editor\"&gt;input method editor&lt;/a&gt;s, keyboard mappings, virtual/on-screen APL symbol sets, or easy-reference printed keyboard cards which can frustrate beginners accustomed to other programming languages. With beginners who have no prior experience with other programming languages, a study involving high school students found that typing and using APL characters did not hinder the students in any measurable way.\nIn defense of APL, it requires fewer characters to type, and keyboard mappings become memorized over time. Special APL keyboards are also made and in use today, as are freely downloadable fonts for operating systems such as Microsoft Windows. The reported productivity gains assume that one spends enough time working in the language to make it worthwhile to memorize the symbols, their semantics, and keyboard mappings, not to mention a substantial number of idioms for common tasks.\nDesign.\nUnlike traditionally structured programming languages, APL code is typically structured as chains of &lt;a href=\"unary%20operation\"&gt;monadic&lt;/a&gt; or &lt;a href=\"binary%20operation\"&gt;dyadic&lt;/a&gt; &lt;a href=\"function%20%28programming%29\"&gt;functions&lt;/a&gt;, and &lt;a href=\"higher-order%20function\"&gt;operators&lt;/a&gt; acting on &lt;a href=\"array%20data%20type\"&gt;arrays&lt;/a&gt;. APL has many nonstandard \"primitives\" (functions and operators) that are indicated by a single symbol or a combination of a few symbols. All primitives are defined to have the same &lt;a href=\"operator%20precedence\"&gt;precedence&lt;/a&gt;, and always associate to the right. Thus, APL is \"read\" or best understood from &lt;a href=\"APL%20syntax%20and%20symbols%23Syntax%20rules\"&gt;right-to-left&lt;/a&gt;.\nEarly APL implementations (circa 1970 or so) had no programming loop-&lt;a href=\"control%20flow\"&gt;flow control&lt;/a&gt; structures, such as codice_1 or codice_2 loops, and codice_3 constructs. Instead, they used array operations, and use of &lt;a href=\"structured%20programming\"&gt;structured programming&lt;/a&gt; constructs was often not necessary, since an operation could be performed on a full array in one statement. For example, the codice_4 function (codice_5) can replace for-loop &lt;a href=\"iteration\"&gt;iteration&lt;/a&gt;: \u03b9N when applied to a scalar positive integer yields a one-dimensional array (vector), 1 2 3\u00a0... N. More recent implementations of APL generally include comprehensive control structures, so that data structure and program control flow can be clearly and cleanly separated.\nThe APL environment is called a \"workspace\". In a workspace the user can define programs and data, i.e., the data values exist also outside the programs, and the user can also manipulate the data without having to define a program. In the examples below, the APL interpreter first types six spaces before awaiting the user's input. Its own output starts in column one.\nThe user can save the workspace with all values, programs, and execution status.\nAPL uses a set of non-&lt;a href=\"ASCII\"&gt;ASCII&lt;/a&gt; symbols, which are an extension of traditional arithmetic and algebraic notation. Having single character names for single instruction, multiple data (&lt;a href=\"Single%20instruction%2C%20multiple%20data\"&gt;SIMD&lt;/a&gt;) vector functions is one way that APL enables compact formulation of algorithms for data transformation such as computing &lt;a href=\"Conway%27s%20Game%20of%20Life\"&gt;Conway's Game of Life&lt;/a&gt; in one line of code. In nearly all versions of APL, it is theoretically possible to express any computable function in one expression, that is, in one line of code.\nBecause of the unusual &lt;a href=\"character%20set\"&gt;character set&lt;/a&gt;, many programmers use special &lt;a href=\"computer%20keyboard\"&gt;keyboards&lt;/a&gt; with APL keytops to write APL code. Although there are various ways to write APL code using only ASCII characters, in practice it is almost never done. (This may be thought to support Iverson's thesis about &lt;a href=\"Linguistic%20relativity\"&gt;notation as a tool of thought&lt;/a&gt;.) Most if not all modern implementations use standard keyboard layouts, with special mappings or &lt;a href=\"input%20method%20editor\"&gt;input method editor&lt;/a&gt;s to access non-ASCII characters. Historically, the APL font has been distinctive, with uppercase italic alphabetic characters and upright numerals and symbols. Most vendors continue to display the APL character set in a custom font.\nAdvocates of APL claim that the examples of so-called \"write-only code\" (badly written and almost incomprehensible code) are almost invariably examples of poor programming practice or novice mistakes, which can occur in any language. Advocates also claim that they are far more productive with APL than with more conventional computer languages, and that working software can be implemented in far less time and with far fewer programmers than using other technology.\nThey also may claim that because it is compact and terse, APL lends itself well to larger-scale software development and complexity, because the number of lines of code can be reduced greatly. Many APL advocates and practitioners also view standard programming languages such as &lt;a href=\"COBOL\"&gt;COBOL&lt;/a&gt; and &lt;a href=\"Java%20%28programming%20language%29\"&gt;Java&lt;/a&gt; as being comparatively tedious. APL is often found where time-to-market is important, such as with trading systems.\nTerminology.\nAPL makes a clear distinction between \"functions\" and \"operators\". Functions take arrays (variables or constants or expressions) as arguments, and return arrays as results. Operators (similar to &lt;a href=\"higher-order%20function\"&gt;higher-order function&lt;/a&gt;s) take functions or arrays as arguments, and derive related functions. For example, the \"sum\" function is derived by applying the \"reduction\" operator to the \"addition\" function. Applying the same reduction operator to the \"maximum\" function (which returns the larger of two numbers) derives a function which returns the largest of a group (vector) of numbers. In the J language, Iverson substituted the terms \"verb\" for \"function\" and \"adverb\" or \"conjunction\" for \"operator\".\nAPL also identifies those features built into the language, and represented by a symbol, or a fixed combination of symbols, as \"primitives\". Most primitives are either functions or operators. Coding APL is largely a process of writing non-primitive functions and (in some versions of APL) operators. However a few primitives are considered to be neither functions nor operators, most noticeably assignment.\nSome words used in APL literature have meanings that differ from those in both mathematics and the generality of computer science.\nSyntax.\nAPL has explicit representations of functions, operators, and syntax, thus providing a basis for the clear and explicit statement of extended facilities in the language, and tools to experiment on them.\nExamples.\nHello, world.\nThis displays \"&lt;a href=\"Hello%2C%20world\"&gt;Hello, world&lt;/a&gt;\":\n'Hello, world'\nA design theme in APL is to define default actions in some cases that would produce syntax errors in most other programming languages.\nThe 'Hello, world' string constant above displays, because display is the default action on any expression for which no action is specified explicitly (e.g. assignment, function parameter).\nExponentiation.\nAnother example of this theme is that exponentiation in APL is written as , which indicates raising 2 to the power 3 (this would be written as in some other languages and in FORTRAN and Python). Many languages use to signify multiplication, as in , but APL chooses to use . However, if no base is specified (as with the statement in APL, or in other languages), most programming languages one would see this as a syntax error. APL, however, assumes the missing base to be the natural logarithm constant &lt;a href=\"e%20%28mathematical%20constant%29\"&gt;e&lt;/a&gt;, and interprets as .\nSimple statistics.\nSuppose that is an array of numbers. Then gives its average. Reading \"right-to-left\", gives the number of elements in X, and since is a dyadic operator, the term to its left is required as well. It is surrounded by parentheses since otherwise X would be taken (so that the summation would be of \u2014 each element of X divided by the number of elements in X), and gives the sum of the elements of X. Building on this, the following expression computes &lt;a href=\"standard%20deviation\"&gt;standard deviation&lt;/a&gt;: \nNaturally, one would define this expression as a function for repeated use rather than rewriting it each time. Further, since assignment is an operator, it can appear within an expression, so the following would place suitable values into T, AV and SD: \n\"Pick 6\" lottery numbers.\nThis following immediate-mode expression generates a typical set of \"Pick 6\" &lt;a href=\"lottery\"&gt;lottery&lt;/a&gt; numbers: six &lt;a href=\"pseudo-random\"&gt;pseudo-random&lt;/a&gt; &lt;a href=\"integer\"&gt;integer&lt;/a&gt;s ranging from 1 to 40, \"guaranteed non-repeating\", and displays them sorted in ascending order:\nx[\u234bx\u21906?40]\nThe above does a lot, concisely, although it may seem complex to a new &lt;a href=\"wiktionary%3AAPLer\"&gt;APLer&lt;/a&gt;. It combines the following APL \"functions\" (also called \"primitives\" and \"glyphs\"):\nSince there is no function to the left of the left-most x to tell APL what to do with the result, it simply outputs it to the display (on a single line, separated by spaces) without needing any explicit instruction to do that.\ncodice_6 also has a monadic equivalent called codice_15, which simply returns one random integer between 1 and its sole operand [to the right of it], inclusive. Thus, a &lt;a href=\"role-playing%20game\"&gt;role-playing game&lt;/a&gt; program might use the expression codice_16 to roll a twenty-sided die.\nPrime numbers.\nThe following expression finds all &lt;a href=\"prime%20number\"&gt;prime number&lt;/a&gt;s from 1 to R. In both time and space, the calculation complexity is formula_1 (in &lt;a href=\"Big%20O%20notation\"&gt;Big O notation&lt;/a&gt;).\n(~R\u220aR\u2218.\u00d7R)/R\u21901\u2193\u2373R\nExecuted from right to left, this means:\nSorting.\nThe following expression &lt;a href=\"sorting\"&gt;sorts&lt;/a&gt; a word list stored in matrix X according to word length:\nX[\u234bX+.\u2260' ';]\nGame of Life.\nThe following function \"life\", written in Dyalog APL, takes a boolean matrix and calculates the new generation according to &lt;a href=\"Conway%27s%20Game%20of%20Life\"&gt;Conway's Game of Life&lt;/a&gt;. It demonstrates the power of APL to implement a complex algorithm in very little code, but it is also very hard to follow unless one has advanced knowledge of APL.\nHTML tags removal.\nIn the following example, also Dyalog, the first line assigns some HTML code to a variable codice_47 and then uses an APL expression to remove all the HTML tags (&lt;a href=\"http%3A//aplwiki.com/AplIn20Minutes%23Extract_content_from_Code\"&gt;explanation&lt;/a&gt;):\n txt\u2190'&lt;html&gt;&lt;body&gt;&lt;p&gt;This is &lt;em&gt;emphasized&lt;/em&gt; text.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'\n {\u2375 /\u2368 ~{\u2375\u2228\u2260\\\u2375}\u2375\u220a'&lt;&gt;'} txt\nThis is emphasized text.\nNaming.\nAPL derives its name from the initials of Iverson's book \"A Programming Language\", even though the book describes &lt;a href=\"%23Mathematical_notation\"&gt;Iverson's mathematical notation&lt;/a&gt;, rather than the implemented programming language described in this article. The name is used only for actual implementations, starting with &lt;a href=\"%23APL%5C360\"&gt;APL\\360&lt;/a&gt;.\n&lt;a href=\"Adin%20Falkoff\"&gt;Adin Falkoff&lt;/a&gt; coined the name in 1966 during the implementation of APL\\360 at &lt;a href=\"IBM\"&gt;IBM&lt;/a&gt;:\n\"APL\" is occasionally re-interpreted as \"Array Programming Language\" or \"Array Processing Language\", thereby making \"APL\" into a &lt;a href=\"backronym\"&gt;backronym&lt;/a&gt;.\nLogo.\nThere has always been cooperation between APL vendors, and joint conferences were held on a regular basis from 1969 until 2010. At such conferences, APL &lt;a href=\"Merchandising\"&gt;merchandise&lt;/a&gt; was often handed out, featuring APL motifs or collection of vendor logos. Common were apples (as a pun on the similarity in pronunciation of \"apple\" and \"APL\") and the code snippet which are the symbols produced by &lt;a href=\"APL_syntax_and_symbols%23APL2_keyboard_function_to_symbol_mapping\"&gt;the classic APL keyboard&lt;/a&gt; layout when holding the APL &lt;a href=\"modifier%20key\"&gt;modifier key&lt;/a&gt; and typing \"APL\".\nDespite all these community efforts, no universal vendor-agnostic logo for the programming language emerged. As popular programming languages increasingly have established recognisable logos, &lt;a href=\"Fortran\"&gt;Fortran&lt;/a&gt; getting one in 2020, British APL Association launched a campaign in the second half of 2021, to establish such a logo for APL.\nUse.\nAPL is used for many purposes including &lt;a href=\"financial%20software\"&gt;financial&lt;/a&gt; and &lt;a href=\"insurance\"&gt;insurance&lt;/a&gt; applications, &lt;a href=\"artificial%20intelligence\"&gt;artificial intelligence&lt;/a&gt;,\n&lt;a href=\"neural%20networks\"&gt;neural networks&lt;/a&gt;\nand &lt;a href=\"robotics\"&gt;robotics&lt;/a&gt;. It has been argued that APL is a &lt;a href=\"calculation\"&gt;calculation&lt;/a&gt; tool and not a programming language; its symbolic nature and array capabilities have made it popular with &lt;a href=\"domain%20expert\"&gt;domain expert&lt;/a&gt;s and &lt;a href=\"data%20scientist\"&gt;data scientist&lt;/a&gt;s who do not have or require the skills of a &lt;a href=\"computer%20programmer\"&gt;computer programmer&lt;/a&gt;.\nAPL is well suited to &lt;a href=\"image%20manipulation\"&gt;image manipulation&lt;/a&gt; and &lt;a href=\"computer%20animation\"&gt;computer animation&lt;/a&gt;, where graphic transformations can be encoded as matrix multiplications. One of the first commercial computer graphics houses, &lt;a href=\"Digital%20Effects%20%28studio%29\"&gt;Digital Effects&lt;/a&gt;, produced an APL graphics product named \"Visions\", which was used to create television commercials and animation for the 1982 film \"&lt;a href=\"Tron\"&gt;Tron&lt;/a&gt;\". Latterly, the &lt;a href=\"https%3A//stormwind.fi/en/\"&gt;Stormwind&lt;/a&gt; &lt;a href=\"Simulation%20video%20game\"&gt;boating simulator&lt;/a&gt; uses APL to implement its core logic, its interfacing to the rendering pipeline middleware and a major part of its &lt;a href=\"physics%20engine\"&gt;physics engine&lt;/a&gt;.\nToday, APL remains in use in a wide range of commercial and scientific applications, for example\n&lt;a href=\"investment%20management\"&gt;investment management&lt;/a&gt;,\n&lt;a href=\"asset%20management\"&gt;asset management&lt;/a&gt;,\n&lt;a href=\"health%20care\"&gt;health care&lt;/a&gt;,\nand &lt;a href=\"DNA%20profiling\"&gt;DNA profiling&lt;/a&gt;, \nand by hobbyists.\nNotable implementations.\nAPL\\360.\nThe first implementation of APL using recognizable APL symbols was APL\\360 which ran on the &lt;a href=\"IBM%20System/360\"&gt;IBM System/360&lt;/a&gt;, and was completed in November 1966 though at that time remained in use only within IBM. In 1973 its implementors, &lt;a href=\"Lawrence%20M.%20Breed\"&gt;Larry Breed&lt;/a&gt;, &lt;a href=\"Richard%20H.%20Lathwell\"&gt;Dick Lathwell&lt;/a&gt; and &lt;a href=\"Roger%20Moore%20%28computer%20scientist%29\"&gt;Roger Moore&lt;/a&gt;, were awarded the &lt;a href=\"Grace%20Murray%20Hopper%20Award\"&gt;Grace Murray Hopper Award&lt;/a&gt; from the &lt;a href=\"Association%20for%20Computing%20Machinery\"&gt;Association for Computing Machinery&lt;/a&gt; (ACM). It was given \"for their work in the design and implementation of APL\\360, setting new standards in simplicity, efficiency, reliability and response time for interactive systems.\"\nIn 1975, the &lt;a href=\"IBM%205100\"&gt;IBM 5100&lt;/a&gt; microcomputer offered APL\\360 as one of two built-in ROM-based interpreted languages for the computer, complete with a keyboard and display that supported all the special symbols used in the language.\nSignificant developments to APL\\360 included CMS/APL, which made use of the &lt;a href=\"Virtual%20memory\"&gt;virtual storage&lt;/a&gt; capabilities of &lt;a href=\"Conversational%20Monitor%20System\"&gt;CMS&lt;/a&gt; and APLSV, which introduced &lt;a href=\"shared%20variable\"&gt;shared variable&lt;/a&gt;s, system variables and system functions. It was subsequently ported to the &lt;a href=\"IBM%20System/370\"&gt;IBM System/370&lt;/a&gt; and &lt;a href=\"Virtual%20Storage%20Personal%20Computing\"&gt;VSPC&lt;/a&gt; platforms until its final release in 1983, after which it was replaced by APL2.\nAPL\\1130.\nIn 1968, APL\\1130 became the first publicly available APL system, created by IBM for the &lt;a href=\"IBM%201130\"&gt;IBM 1130&lt;/a&gt;. It became the most popular &lt;a href=\"IBM%20Type-III%20Library\"&gt;IBM Type-III Library&lt;/a&gt; software that IBM released.\nAPL*Plus and Sharp APL.\nAPL*Plus and Sharp APL are versions of APL\\360 with added business-oriented extensions such as data formatting and facilities to store APL arrays in external files. They were jointly developed by two companies, employing various members of the original IBM APL\\360 development team.\nThe two companies were &lt;a href=\"I.%20P.%20Sharp%20Associates\"&gt;I. P. Sharp Associates&lt;/a&gt; (IPSA), an APL\\360 services company formed in 1964 by Ian Sharp, Roger Moore and others, and &lt;a href=\"Scientific%20Time%20Sharing%20Corporation\"&gt;STSC&lt;/a&gt;, a time-sharing and consulting service company formed in 1969 by Lawrence Breed and others. Together the two developed APL*Plus and thereafter continued to work together but develop APL separately as APL*Plus and Sharp APL. STSC ported APL*Plus to many platforms with versions being made for the VAX 11, PC and UNIX, whereas IPSA took a different approach to the arrival of the &lt;a href=\"personal%20computer\"&gt;personal computer&lt;/a&gt; and made Sharp APL available on this platform using additional &lt;a href=\"PC-based%20IBM-compatible%20mainframes\"&gt;PC-XT/360&lt;/a&gt; hardware. In 1993, &lt;a href=\"Soliton%20Incorporated\"&gt;Soliton Incorporated&lt;/a&gt; was formed to support Sharp APL and it developed Sharp APL into SAX (Sharp APL for Unix). , APL*Plus continues as APL2000 APL+Win.\nIn 1985, Ian Sharp, and Dan Dyer of STSC, jointly received the &lt;a href=\"Iverson%20Award\"&gt;Kenneth E. Iverson Award for Outstanding Contribution to APL&lt;/a&gt;.\nAPL2.\nAPL2 was a significant re-implementation of APL by IBM which was developed from 1971 and first released in 1984. It provides many additions to the language, of which the most notable is nested (non-rectangular) array support. The entire APL2 Products and Services Team was awarded the Iverson Award in 2007.\nIn 2021, IBM sold APL2 to Log-On Software, who develop and sell the product as \"Log-On APL2\".\nAPLGOL.\nIn 1972, APLGOL was released as an experimental version of APL that added structured programming language constructs to the language framework. New statements were added for interstatement control, conditional statement execution, and statement structuring, as well as statements to clarify the intent of the algorithm. It was implemented for Hewlett-Packard in 1977.\nDyalog APL.\nDyalog APL was first released by &lt;a href=\"United%20Kingdom\"&gt;British&lt;/a&gt; company Dyalog Ltd. in 1983 and, , is available for &lt;a href=\"IBM%20AIX\"&gt;AIX&lt;/a&gt;, &lt;a href=\"Linux\"&gt;Linux&lt;/a&gt; (including on the &lt;a href=\"Raspberry%20Pi\"&gt;Raspberry Pi&lt;/a&gt;), &lt;a href=\"macOS\"&gt;macOS&lt;/a&gt; and &lt;a href=\"Microsoft%20Windows\"&gt;Microsoft Windows&lt;/a&gt; platforms. It is based on APL2, with extensions to support &lt;a href=\"object-oriented%20programming\"&gt;object-oriented programming&lt;/a&gt; and &lt;a href=\"functional%20programming\"&gt;functional programming&lt;/a&gt;. Licences are free for personal/non-commercial use.\nIn 1995, two of the development team - &lt;a href=\"John%20M.%20Scholes%20%28computer%20scientist%29\"&gt;John Scholes&lt;/a&gt; and Peter Donnelly - were awarded the Iverson Award for their work on the interpreter. Gitte Christensen and Morten Kromberg were joint recipients of the Iverson Award in 2016.\nNARS2000.\nNARS2000 is an open-source APL interpreter written by Bob Smith, a prominent APL developer and implementor from &lt;a href=\"Scientific%20Time%20Sharing%20Corporation\"&gt;STSC&lt;/a&gt; in the 1970s and 1980s. NARS2000 contains advanced features and new datatypes and runs natively on &lt;a href=\"Microsoft%20Windows\"&gt;Microsoft Windows&lt;/a&gt;, and other platforms under &lt;a href=\"Wine%20%28software%29\"&gt;Wine&lt;/a&gt;. It is named after a development tool from the 1980s, NARS (Nested Arrays Research System).\nAPLX.\nAPLX is a &lt;a href=\"cross-platform\"&gt;cross-platform&lt;/a&gt; &lt;a href=\"Programming%20language%20dialect\"&gt;dialect&lt;/a&gt; of APL, based on APL2 and with several extensions, which was first released by &lt;a href=\"United%20Kingdom\"&gt;British&lt;/a&gt; company MicroAPL in 2002. Although no longer in development or on commercial sale it is now available free of charge from Dyalog.\nGNU APL.\nGNU APL is a free implementation of Extended APL as specified in ISO/IEC 13751:2001 and is thus an implementation of APL2. It runs on &lt;a href=\"Linux\"&gt;Linux&lt;/a&gt; (including on the Raspberry Pi), macOS, several BSD dialects, and on Windows (either using &lt;a href=\"Cygwin\"&gt;Cygwin&lt;/a&gt; for full support of all its system functions or as a native 64-bit Windows binary with some of its system functions missing). GNU APL uses &lt;a href=\"Unicode\"&gt;Unicode&lt;/a&gt; internally and can be scripted. It was written by J\u00fcrgen Sauermann.\n&lt;a href=\"Richard%20Stallman\"&gt;Richard Stallman&lt;/a&gt;, founder of the &lt;a href=\"GNU%20Project\"&gt;GNU Project&lt;/a&gt;, was an early adopter of APL, using it to write a text editor as a high school student in the summer of 1969.\nInterpretation and compilation of APL.\nAPL is traditionally an &lt;a href=\"interpreted%20language\"&gt;interpreted language&lt;/a&gt;, having language characteristics such as &lt;a href=\"Strong%20and%20weak%20typing\"&gt;weak variable typing&lt;/a&gt; not well suited to &lt;a href=\"compiler\"&gt;compilation&lt;/a&gt;. However, with arrays as its core data structure it provides opportunities for performance gains through &lt;a href=\"Data%20parallelism\"&gt;parallelism&lt;/a&gt;, &lt;a href=\"parallel%20computing\"&gt;parallel computing&lt;/a&gt;, &lt;a href=\"Massively%20parallel%20%28computing%29\"&gt;massively parallel&lt;/a&gt; applications, and &lt;a href=\"very-large-scale%20integration\"&gt;very-large-scale integration&lt;/a&gt; (VLSI), and from the outset APL has been regarded as a high-performance language - for example, it was noted for the speed with which it could perform complicated matrix operations \"because it operates on arrays and performs operations like matrix inversion internally\".\nNevertheless, APL is rarely purely interpreted and compilation or partial compilation techniques that are, or have been, used include the following:\nIdiom recognition.\nMost APL interpreters support &lt;a href=\"Programming%20idiom\"&gt;idiom&lt;/a&gt; recognition and evaluate common idioms as single operations. For example, by evaluating the idiom codice_48 as a single operation (where codice_49 is a Boolean vector and codice_50 is an array), the creation of two intermediate arrays is avoided.\nOptimised bytecode.\nWeak typing in APL means that a name may reference an array (of any datatype), a function or an operator. In general, the interpreter cannot know in advance which form it will be and must therefore perform analysis, syntax checking etc. at run-time. However, in certain circumstances, it is possible to deduce in advance what type a name is expected to reference and then generate &lt;a href=\"bytecode\"&gt;bytecode&lt;/a&gt; which can be executed with reduced run-time overhead. This bytecode can also be optimised using compilation techniques such as &lt;a href=\"constant%20folding\"&gt;constant folding&lt;/a&gt; or &lt;a href=\"common%20subexpression%20elimination\"&gt;common subexpression elimination&lt;/a&gt;. The interpreter will execute the bytecode when present and when any assumptions which have been made are met. Dyalog APL includes support for optimised bytecode.\nCompilation.\n&lt;a href=\"Compiler\"&gt;Compilation&lt;/a&gt; of APL has been the subject of research and experiment since the language first became available; the first compiler is considered to be the Burroughs APL-700 which was released around 1971. In order to be able to compile APL, language limitations have to be imposed. APEX is a research APL compiler which was written by &lt;a href=\"Robert%20Bernecky\"&gt;Robert Bernecky&lt;/a&gt; and is available under the &lt;a href=\"GNU%20Public%20License\"&gt;GNU Public License&lt;/a&gt;.\nThe &lt;a href=\"STSC\"&gt;STSC&lt;/a&gt; APL Compiler is a hybrid of a bytecode optimiser and a compiler - it enables compilation of functions to &lt;a href=\"machine%20code\"&gt;machine code&lt;/a&gt; provided that its sub-functions and globals are &lt;a href=\"Declaration%20%28computer%20programming%29\"&gt;declared&lt;/a&gt;, but the interpreter is still used as a &lt;a href=\"runtime%20library\"&gt;runtime library&lt;/a&gt; and to execute functions which do not meet the compilation requirements.\nStandards.\nAPL has been standardized by the &lt;a href=\"American%20National%20Standards%20Institute\"&gt;American National Standards Institute&lt;/a&gt; (ANSI) &lt;a href=\"working%20group\"&gt;working group&lt;/a&gt; X3J10 and &lt;a href=\"International%20Organization%20for%20Standardization\"&gt;International Organization for Standardization&lt;/a&gt; (ISO) and &lt;a href=\"International%20Electrotechnical%20Commission\"&gt;International Electrotechnical Commission&lt;/a&gt; (IEC), ISO/IEC Joint Technical Committee 1 Subcommittee 22 Working Group 3. The Core APL language is specified in ISO 8485:1989, and the Extended APL language is specified in ISO/IEC 13751:2001."
}