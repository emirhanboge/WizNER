{
    "id": "1350138",
    "revid": "1068235682",
    "url": "https://en.wikipedia.org/wiki?curid=1350138",
    "title": "Micro-Controller Operating Systems",
    "text": "Micro-Controller Operating Systems (MicroC/OS, stylized as \u03bcC/OS) is a &lt;a href=\"real-time%20operating%20system\"&gt;real-time operating system&lt;/a&gt; (RTOS) designed by Jean J. Labrosse in 1991. It is a priority-based &lt;a href=\"Preemption%20%28computing%29\"&gt;preemptive&lt;/a&gt; &lt;a href=\"Real-time%20computing\"&gt;real-time&lt;/a&gt; kernel for &lt;a href=\"microprocessor\"&gt;microprocessor&lt;/a&gt;s, written mostly in the programming language &lt;a href=\"C%20%28programming%20language%29\"&gt;C&lt;/a&gt;. It is intended for use in &lt;a href=\"embedded%20system\"&gt;embedded system&lt;/a&gt;s.\nMicroC/OS allows defining several functions in C, each of which can execute as an independent thread or task. Each task runs at a different priority, and runs as if it owns the &lt;a href=\"central%20processing%20unit\"&gt;central processing unit&lt;/a&gt; (CPU). Lower priority tasks can be preempted by higher priority tasks at any time. Higher priority tasks use operating system (OS) services (such as a delay or event) to allow lower priority tasks to execute. OS services are provided for managing tasks and memory, communicating between tasks, and timing.\nHistory.\nThe MicroC/OS kernel was published originally in a three-part article in Embedded Systems Programming magazine and the book \"\u03bcC/OS The Real-Time Kernel\" by Jean J. Labrosse (). The author intended at first to simply describe the internals of a &lt;a href=\"Software%20portability\"&gt;portable&lt;/a&gt; operating system he had developed for his own use, but later developed the OS as a commercial product in versions II and III.\n\u03bcC/OS-II.\nBased on the source code written for \u03bcC/OS, and introduced as a commercial product in 1998, \u03bcC/OS-II is a &lt;a href=\"Software%20portability\"&gt;portable&lt;/a&gt;, ROM-able, &lt;a href=\"scalable\"&gt;scalable&lt;/a&gt;, preemptive, real-time, deterministic, multitasking &lt;a href=\"Kernel%20%28operating%20system%29\"&gt;kernel&lt;/a&gt; for &lt;a href=\"microprocessor\"&gt;microprocessor&lt;/a&gt;s, and &lt;a href=\"digital%20signal%20processor\"&gt;digital signal processor&lt;/a&gt;s (DSPs). It manages up to 64 tasks. Its size can be scaled (between 5 and 24 Kbytes) to only contain the features needed for a given use.\nMost of \u03bcC/OS-II is written in highly portable &lt;a href=\"ANSI%20C\"&gt;ANSI C&lt;/a&gt;, with target microprocessor-specific code written in &lt;a href=\"assembly%20language\"&gt;assembly language&lt;/a&gt;. Use of the latter is minimized to ease &lt;a href=\"porting\"&gt;porting&lt;/a&gt; to other processors.\nUses in embedded systems.\n\u03bcC/OS-II was designed for embedded uses. If the producer has the proper tool chain (i.e., C compiler, assembler, and linker-locator), \u03bcC/OS-II can be embedded as part of a product.\n\u03bcC/OS-II is used in many embedded systems, including:\nTask states.\n\u03bcC/OS-II is a &lt;a href=\"Computer%20multitasking\"&gt;multitasking&lt;/a&gt; operating system. Each task is an infinite loop and can be in any one of the following five states (see figure below additionally)\nFurther, it can manage up to 64 tasks. However, it is recommended that eight of these tasks be reserved for \u03bcC/OS-II, leaving an application up to 56 tasks.\nKernels.\nThe &lt;a href=\"Kernel%20%28operating%20system%29\"&gt;kernel&lt;/a&gt; is the name given to the program that does most of the housekeeping tasks for the operating system. The boot loader hands control over to the kernel, which initializes the various devices to a known state and makes the computer ready for general operations. The kernel is responsible for managing tasks (i.e., for managing the CPU's time) and communicating between tasks. The fundamental service provided by the kernel is &lt;a href=\"context%20switch\"&gt;context switch&lt;/a&gt;ing.\nThe &lt;a href=\"scheduler\"&gt;scheduler&lt;/a&gt; is the part of the kernel responsible for determining which task runs next. Most real-time kernels are priority based. In a priority-based kernel, control of the CPU is always given to the highest priority task ready to run. Two types of priority-based kernels exist: &lt;a href=\"Computer%20multitasking%23Cooperative%20multitasking\"&gt;non-preemptive&lt;/a&gt; and &lt;a href=\"Preemption%20%28computing%29\"&gt;preemptive&lt;/a&gt;. Nonpreemptive kernels require that each task do something to explicitly give up control of the CPU. A preemptive kernel is used when system responsiveness is more important. Thus, \u03bcC/OS-II and most commercial real-time kernels are preemptive. The highest priority task ready to run is always given control of the CPU.\nAssigning tasks.\nTasks with the highest rate of execution are given the highest priority using &lt;a href=\"rate-monotonic%20scheduling\"&gt;rate-monotonic scheduling&lt;/a&gt;. This scheduling algorithm is used in real-time operating systems (RTOS) with a &lt;a href=\"static-priority%20scheduling%20class\"&gt;static-priority scheduling class&lt;/a&gt;.\nManaging tasks.\nIn &lt;a href=\"computing\"&gt;computing&lt;/a&gt;, a task is a unit of &lt;a href=\"execution\"&gt;execution&lt;/a&gt;. In some &lt;a href=\"operating%20systems\"&gt;operating systems&lt;/a&gt;, a task is synonymous with a &lt;a href=\"Process%20%28computing%29\"&gt;process&lt;/a&gt;, in others with a &lt;a href=\"Thread%20%28computing%29\"&gt;thread&lt;/a&gt;. In &lt;a href=\"batch%20processing\"&gt;batch processing&lt;/a&gt; computer systems, a task is a unit of execution within a &lt;a href=\"Job%20stream\"&gt;job&lt;/a&gt;.\nThe system user of \u03bcC/OS-II is able to control the tasks by using the following features:\nManaging memory.\nTo avoid &lt;a href=\"Fragmentation%20%28computing%29\"&gt;fragmentation&lt;/a&gt;, \u03bcC/OS-II allows applications to obtain fixed-sized memory blocks from a &lt;a href=\"Memory%20management%20%28operating%20systems%29%23Partitioned%20allocation\"&gt;partition&lt;/a&gt; made of a contiguous memory area. All memory blocks are the same size, and the partition contains an &lt;a href=\"integral\"&gt;integral&lt;/a&gt; number of blocks. Allocation and deallocation of these memory blocks is done in constant time and is a &lt;a href=\"deterministic%20system\"&gt;deterministic system&lt;/a&gt;.\nManaging time.\n\u03bcC/OS-II requires that a periodic time source be provided to keep track of time delays and timeouts. A tick should occur between 10 and 1000 times per second, or &lt;a href=\"Hertz\"&gt;Hertz&lt;/a&gt;. The faster the tick rate, the more &lt;a href=\"Overhead%20%28computing%29\"&gt;overhead&lt;/a&gt; \u03bcC/OS-II imposes on the system. The frequency of the clock tick depends on the desired tick resolution of an application. Tick sources can be obtained by dedicating a hardware timer, or by generating an &lt;a href=\"interrupt\"&gt;interrupt&lt;/a&gt; from an &lt;a href=\"alternating%20current\"&gt;alternating current&lt;/a&gt; (AC) power line (50 or 60\u00a0Hz) signal. This periodic time source is termed a clock tick.\nAfter a \"clock tick\" is determined, tasks can be: \nCommunicating between tasks.\nIntertask or interprocess communication in \u03bcC/OS-II occurs via: &lt;a href=\"Semaphore%20%28programming%29\"&gt;semaphores&lt;/a&gt;, message mailbox, message queues, tasks, and &lt;a href=\"Interrupt%20handler\"&gt;interrupt service routines&lt;/a&gt; (ISRs). They can interact with each other when a task or an ISR signals a task through a kernel object called an event control block (ECB). The signal is considered to be an event.\n\u03bcC/OS-III.\n\u03bcC/OS-III is the acronym for Micro-Controller Operating Systems Version 3, introduced in 2009 and adding functionality to the \u03bcC/OS-II RTOS.\n\u03bcC/OS-III offers all of the features and functions of \u03bcC/OS-II. The biggest difference is the number of supported tasks. \u03bcC/OS-II allows only 1 task at each of 255 priority levels, for a maximum of 255 tasks. \u03bcC/OS-III allows any number of application tasks, priority levels, and tasks per level, limited only by processor access to memory.\n\u03bcC/OS-II and \u03bcC/OS-III are currently maintained by Micrium, Inc., a subsidiary of Silicon Labs, and can be licensed per product or per product line.\nUses in embedded systems.\nThe uses are the same as for \u03bcC/OS-II\nTask states.\n\u03bcC/OS-III is a &lt;a href=\"Computer%20multitasking\"&gt;multitasking&lt;/a&gt; operating system. Each task is an infinite loop and can be in any one of five states (dormant, ready, running, interrupted, or pending). Task priorities can range from 0 (highest priority) to a maximum of 255 (lowest possible priority).\nRound robin scheduling.\nWhen two or more tasks have the same priority, the kernel allows one task to run for a predetermined amount of time, named a \"quantum\", and then selects another task. This process is termed &lt;a href=\"round%20robin%20scheduling\"&gt;round robin scheduling&lt;/a&gt; or time slicing. The kernel gives control to the next task in line if:\nKernels.\nThe kernel functionality for \u03bcC/OS-III is the same as for \u03bcC/OS-II.\nManaging tasks.\nTask management also functions the same as for \u03bcC/OS-II. However, \u03bcC/OS-III supports multitasking and allows an application to have any number of tasks. The maximum number of tasks is limited by only the amount of computer memory (both code and data space) available to the processor.\nA task can be implemented viarunning to scheduled completion, in which the task deletes itself when it is finished, or more typically as an infinite loop, waiting for events to occur and processing those events.\nManaging memory.\nMemory management is performed in the same way as in \u03bcC/OS-II.\nManaging time.\n\u03bcC/OS-III offers the same time managing features as \u03bcC/OS-II. It also provides services to applications so that tasks can suspend their execution for user-defined time delays. Delays are specified by a number of either clock ticks, or hours, minutes, seconds, and &lt;a href=\"millisecond\"&gt;millisecond&lt;/a&gt;s.\nCommunicating between tasks.\nSometimes, a task or ISR must communicate information to another task, because it is \"unsafe\" for two tasks to access the same specific data or hardware resource at once. This can be resolved via an information transfer, termed inter-task communication. Information can be communicated between tasks in two ways: through global data, or by sending messages.\nWhen using global variables, each task or ISR must ensure that it has exclusive access to variables. If an ISR is involved, the only way to ensure exclusive access to common variables is to disable &lt;a href=\"interrupt\"&gt;interrupt&lt;/a&gt;s. If two tasks share data, each can gain exclusive access to variables by either disabling interrupts, locking the scheduler, using a &lt;a href=\"Semaphore%20%28programming%29\"&gt;semaphore&lt;/a&gt;, or preferably, using a &lt;a href=\"mutual%20exclusion\"&gt;mutual exclusion&lt;/a&gt; semaphore. Messages can be sent to either an intermediate object called a &lt;a href=\"message%20queue\"&gt;message queue&lt;/a&gt;, or directly to a task, since in \u03bcC/OS-III, each task has its own built-in message queue. Use an external message queue if multiple tasks are to wait for messages. Send a message directly to a task if only one task will process the data received. While a task waits for a message to arrive, it uses no CPU time.\nPorts.\nA port involves three aspects: CPU, OS, and board specific (BSP) code. \u03bcC/OS-II and \u03bcC/OS-III have ports for most popular processors and boards in the market and are suitable for use in &lt;a href=\"safety%20critical\"&gt;safety critical&lt;/a&gt; embedded systems such as aviation, medical systems, and nuclear installations. A \u03bcC/OS-III port involves writing or changing the contents of three kernel specific files: codice_1, codice_2, and codice_3. It is necessary to write or change the content of three CPU specific files: codice_4, codice_5, and codice_6. Finally create or change a board support package (BSP) for the evaluation board or target board being used. A \u03bcC/OS-III port is similar to a \u03bcC/OS-II port. There are significantly more ports than listed here, and ports are subject to continuous development. Both \u03bcC/OS-II and \u03bcC/OS-III are supported by popular &lt;a href=\"Transport%20Layer%20Security\"&gt;SSL/TLS&lt;/a&gt; libraries such as &lt;a href=\"wolfSSL\"&gt;wolfSSL&lt;/a&gt;, which ensure security across all connections. \nLicensing Change.\nAfter acquisition by Silicon Labs, Micrium in 2020 has changed to an Open Source licensing model in February 2020. This includes uC/OS III, all prior versions, all components (USB, file system, GUI, TCP/IP, etc).\nDocumentation and Support.\nIn addition to a typical support forum, a number of well-written books are available. Books are available as free PDFs, or for low-cost purchase as hard-cover books. A number of books are each tailored to a particular microcontroller architecture / development platform.\nPaid support is available from Micrium and others."
}