{
    "id": "236683",
    "revid": "22004915",
    "url": "https://en.wikipedia.org/wiki?curid=236683",
    "title": "Amortized analysis",
    "text": "In &lt;a href=\"computer%20science\"&gt;computer science&lt;/a&gt;, amortized analysis is a method for &lt;a href=\"Analysis%20of%20algorithms\"&gt;analyzing&lt;/a&gt; a given algorithm's &lt;a href=\"Computational%20complexity%20theory\"&gt;complexity&lt;/a&gt;, or how much of a resource, especially time or memory, it takes to &lt;a href=\"Execution%20%28computing%29\"&gt;execute&lt;/a&gt;. The motivation for amortized analysis is, that looking at the worst-case run time can be too pessimistic. Instead, amortized analysis averages the running times of operations in a sequence over that sequence.\nAs a conclusion: \u201cAmortized analysis is a useful tool that complements other techniques such as &lt;a href=\"Worst-case%20execution%20time\"&gt;worst-case&lt;/a&gt; and &lt;a href=\"Average-case%20complexity\"&gt;average-case&lt;/a&gt; analysis.\u201c\nFor a given operation of an algorithm, certain situations (e.g., input parametrizations or data structure contents) may imply a significant cost in resources, whereas other situations may not be as costly. The amortized analysis considers both the costly and less costly operations together over the whole sequence of operations. This may include accounting for different types of input, length of the input, and other factors that affect its performance.\nHistory.\nAmortized analysis initially emerged from a method called aggregate analysis, which is now subsumed by amortized analysis. The technique was first formally introduced by &lt;a href=\"Robert%20Tarjan\"&gt;Robert Tarjan&lt;/a&gt; in his 1985 paper \"Amortized Computational Complexity\", which addressed the need for a more useful form of analysis than the common probabilistic methods used. Amortization was initially used for very specific types of algorithms, particularly those involving &lt;a href=\"binary%20tree\"&gt;binary tree&lt;/a&gt;s and &lt;a href=\"Union%20%28computer%20science%29\"&gt;union&lt;/a&gt; operations. However, it is now ubiquitous and comes into play when analyzing many other algorithms as well.\nMethod.\nAmortized analysis requires knowledge of which series of operations are possible. This is most commonly the case with &lt;a href=\"data%20structure\"&gt;data structure&lt;/a&gt;s, which have &lt;a href=\"state%20%28computer%20science%29\"&gt;state&lt;/a&gt; that persists between operations. The basic idea is that a worst-case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus \"amortizing\" its cost.\nThere are generally three methods for performing amortized analysis: the aggregate method, the &lt;a href=\"accounting%20method\"&gt;accounting method&lt;/a&gt;, and the &lt;a href=\"potential%20method\"&gt;potential method&lt;/a&gt;. All of these give correct answers; the choice of which to use depends on which is most convenient for a particular situation.\nExamples.\nDynamic array.\nConsider a &lt;a href=\"dynamic%20array\"&gt;dynamic array&lt;/a&gt; that grows in size as more elements are added to it, such as in Java or in C++. If we started out with a dynamic array of size 4, we could push 4 elements onto it, and each operation would take &lt;a href=\"constant%20time\"&gt;constant time&lt;/a&gt;. Yet pushing a fifth element onto that array would take longer as the array would have to create a new array of double the current size (8), copy the old elements onto the new array, and then add the new element. The next three push operations would similarly take constant time, and then the subsequent addition would require another slow doubling of the array size.\nIn general if we consider an arbitrary number of pushes \"n\" + 1 to an array of size \"n\", we notice that push operations take constant time except for the last one which takes &lt;a href=\"Big%20O%20notation\"&gt;&lt;/a&gt; time to perform the size doubling operation. Since there were \"n\" + 1 operations total we can take the average of this and find that pushing elements onto the dynamic array takes: formula_1, constant time.\nQueue.\nShown is a Ruby implementation of a &lt;a href=\"Queue%20%28abstract%20data%20type%29\"&gt;Queue&lt;/a&gt;, a &lt;a href=\"FIFO%20%28computing%20and%20electronics%29\"&gt;FIFO data structure&lt;/a&gt;:\nclass Queue\n def initialize\n @input = []\n @output = []\n end\n def enqueue(element)\n @input \u00ab element\n end\n def dequeue\n if @output.empty?\n while @input.any?\n @output \u00ab @input.pop\n end\n end\n @output.pop\n end\nend\nThe enqueue operation just pushes an element onto the input array; this operation does not depend on the lengths of either input or output and therefore runs in constant time.\nHowever the dequeue operation is more complicated. If the output array already has some elements in it, then dequeue runs in constant time; otherwise, dequeue takes time to add all the elements onto the output array from the input array, where \"n\" is the current length of the input array. After copying \"n\" elements from input, we can perform \"n\" dequeue operations, each taking constant time, before the output array is empty again. Thus, we can perform a sequence of \"n\" dequeue operations in only time, which implies that the amortized time of each dequeue operation is .\nAlternatively, we can charge the cost of copying any item from the input array to the output array to the earlier enqueue operation for that item. This charging scheme doubles the amortized time for enqueue but reduces the amortized time for dequeue to ."
}