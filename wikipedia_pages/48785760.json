{
    "id": "48785760",
    "revid": "28481209",
    "url": "https://en.wikipedia.org/wiki?curid=48785760",
    "title": "K-connectivity certificate",
    "text": "In &lt;a href=\"graph%20theory\"&gt;graph theory&lt;/a&gt;, for a &lt;a href=\"K-connected%20graph\"&gt;k-connected&lt;/a&gt; &lt;a href=\"Graph%20%28discrete%20mathematics%29\"&gt;graph&lt;/a&gt; G = (V, E), a subset of edges formula_1 is considered a certificate for the &lt;a href=\"K-connected%20graph\"&gt;k-connectivity&lt;/a&gt; of the graph G if and only if the subgraph G' = (V, E') is &lt;a href=\"K-connected%20graph\"&gt;k-connected&lt;/a&gt;.\nSparse certificates.\nFor a k-connected graph with \"n\" &lt;a href=\"Vertex%20%28graph%20theory%29\"&gt;vertices&lt;/a&gt;, there always exists a &lt;a href=\"K-vertex-connected%20graph\"&gt;\"k\"-connectivity&lt;/a&gt; certificate with at most k(n-1) edges. K-connectivity certificates are considered sparse if they contain \"O\"(\"kn\") edges. In this figure, the graph on the right is also a sparse certificate for the graph \"G\" on the left.\nScan-first search.\nScan-First is an algorithm for the parallel construction of &lt;a href=\"K-vertex-connected%20graph\"&gt;k-connectivity&lt;/a&gt; certificates for graphs. It was introduced in the paper Scan-First Search and Sparse Certificates: An Improved Parallel Algorithm for &lt;a href=\"K-vertex-connected%20graph\"&gt;K-Vertex Connectivity&lt;/a&gt; by Joseph Cheriyan, Ming-Yang Kao, and Ramakrishna Thurimella. The Scan-First Search algorithm improves the running time of building a sparse certificate for &lt;a href=\"K-vertex-connected%20graph\"&gt;k-connectivity&lt;/a&gt; using the parallel computation model.\nWe can find a sparse certificate for k-connectivity by iteratively running scan-first search k times on sub-graphs of our input graph. Our input is a graph G = (V, E) and a root vertex r. For each iteration of scan-first search, we first compute a spanning tree T of our input graph G, and assign a pre-order numbering to all the vertices, which we will use as our scanning order. From our root r, we first scan r, which involves marking all its neighboring vertices.\nGiven a connected undirected graph and a specified vertex, a scan-first search in the graph starting from the specified vertex is a systematic way of marking the vertices. The main marking step is called \"scan\": to scan a marked vertex means to mark all previously unmarked neighbors of that vertex. At the beginning of the search, only the specified starting vertex is marked. Then the search iteratively scans a marked and unscanned vertex until all vertices are scanned.\nA scan-first search in a connected undirected graph produces a spanning tree defined as follows. At the beginning of the search, the tree is empty. Then, for each vertex x in the graph, when x is scanned, all the edges between x and its previously unmarked neighbors are added to the tree; the edges between x and its previously marked neighbors are not added to the tree.\nAll previously unmarked vertices constitute the end-point of an edge from the currently scanned vertex, so if we start from some vertex v, and it has neighbors w and x, then if both w and x are unmarked, we create the edges (v, w) and (v, x) and add them to our output tree T'. If either w or x was previously marked, we do not add the edge that includes that vertex to T'. With these new edges in T', we move to the next vertex with the lowest preorder number to scan, which involves continuously marking previously unmarked vertices and adding the edges from the current vertex to these vertices to our output tree.\nWe use scan-first search to generate certificates for k-connectivity by running it for k iterations. An important note moving forward is that for each edge added to some output tree T' in each iteration, we remove the edges from the original graph G so they may not be included in some spanning forest for the next iteration. However, we can view the markings on the vertices as reset, so no vertices are marked on the next iteration.\nOnce we have exhausted all vertices, we have an edge set for the first iteration, E1. We then remove E1 from G = G0, and make that G1, and move onto the second iteration using the graph G1. At the end of each iteration we have:\nWe say that \"Hk\" is the sparse certificate for the graph G.\nThe Main Certificate Theorem.\nGiven an undirected &lt;a href=\"Graph%20%28discrete%20mathematics%29\"&gt;graph&lt;/a&gt; \"G\" = (\"V\", \"E\") with \"n\" vertices, let \"k\" be some positive integer. For all \"i\" = 1, 2, . . . , \"k\", let \"E\"\"i\" be the set of edges generated by the \"i\"-th iteration of scan-first search, corresponding to a graph \"G\"\"i\"\u22121 = (\"V\", \"E\" \u2212 (\"E\"1 \u222a . . . \u222a \"E\"\"i\"\u22121)). So for each iteration of scan-first search, as stated above, we will remove edges from the graph \"G\" to create some new graph \"G\"\"i\" that results at the end of the \"i\"th iteration. For every iteration \"i\", our scan-first search forest is built from the graph \"G\"\"i\"\u22121, where \"G\" = \"G\"0. The claim of the Main Certificate Theorem is that the union \"E\"1 \u222a . . . \u222a \"E\"\"k\" is a certificate for the \"k\"-vertex connectivity of \"G\" and that it has at most edges.\nComputational complexity.\nThe most important running-time is that of the algorithm running in parallel, using the CRCW PRAM model in this case. Our first spanning tree \"T\" can be found in time using \"C\"(\"n\",\"m\") processors. Our preorder numbers and neighbours can also be calculated in O(log n) time because parallel techniques with processors, our \"C\"(\"n\",\"m\") value. For this reason, we can generate a single \"T&amp;prime\" corresponding to one iteration in \"O\"(log \"n\") time.\nUsing a distributed breadth-first search approach, we can find our spanning forest in time on a graph with diameter \"d\" using messages. The sequential approach is quite simply the running time for breadth-first search, ."
}