{
    "id": "8628057",
    "revid": "1588193",
    "url": "https://en.wikipedia.org/wiki?curid=8628057",
    "title": "Hardware performance counter",
    "text": "In &lt;a href=\"computer\"&gt;computer&lt;/a&gt;s, hardware performance counters (HPC), or hardware counters are a set of special-purpose &lt;a href=\"Processor%20register\"&gt;register&lt;/a&gt;s built into modern &lt;a href=\"microprocessor\"&gt;microprocessor&lt;/a&gt;s to store the counts of hardware-related activities within computer systems. Advanced users often rely on those counters to conduct low-level &lt;a href=\"Profiling%20%28computer%20programming%29\"&gt;performance analysis&lt;/a&gt; or &lt;a href=\"Performance%20tuning\"&gt;tuning&lt;/a&gt;.\nImplementations.\nThe number of available hardware counters in a processor is limited while each &lt;a href=\"Central%20processing%20unit\"&gt;CPU&lt;/a&gt; model might have a lot of different events that a developer might like to measure. Each counter can be programmed with the index of an event type to be monitored, like a L1 cache miss or a branch misprediction.\nOne of the first processors to implement such counter and an associated instruction codice_1 to access it was the &lt;a href=\"Intel\"&gt;Intel&lt;/a&gt; &lt;a href=\"Pentium\"&gt;Pentium&lt;/a&gt;, but they were not documented until &lt;a href=\"Terje%20Mathisen\"&gt;Terje Mathisen&lt;/a&gt; wrote an article about reverse engineering them in \"&lt;a href=\"Byte%20%28magazine%29\"&gt;Byte&lt;/a&gt;\" July 1994. \nThe following table shows some examples of CPUs and the number of available hardware counters:\nVersus software techniques.\nCompared to software &lt;a href=\"Profiling%20%28computer%20programming%29\"&gt;profilers&lt;/a&gt;, hardware counters provide low-overhead access to a wealth of detailed performance information related to CPU's functional units, caches and main memory etc. Another benefit of using them is that no source code modifications are needed in general. However, the types and meanings of hardware counters vary from one kind of architecture to another due to the variation in hardware organizations.\nThere can be difficulties correlating the low level performance metrics back to source code. The limited number of registers to store the counters often force users to conduct multiple measurements to collect all desired performance metrics. \nInstruction based sampling.\nModern &lt;a href=\"superscalar\"&gt;superscalar&lt;/a&gt; processors schedule and execute multiple instructions &lt;a href=\"Out-of-order%20execution\"&gt;out-of-order&lt;/a&gt; at one time. These \"in-flight\" instructions can retire at any time, depending on memory access, hits in cache, stalls in the pipeline and many other factors. This can cause performance counter events to be attributed to the wrong instructions, making precise performance analysis difficult or impossible. \nAMD introduced methods to mitigate some of these drawbacks. For example, the Opteron processors have implemented in 2007 a technique known as Instruction Based Sampling (or IBS). AMD's implementation of IBS provides hardware counters for both fetch sampling (the front of the superscalar pipeline) and op sampling (the back of the pipeline). This results in discrete performance data associating retired instructions with the \"parent\" AMD64 instruction."
}