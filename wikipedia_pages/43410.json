{
    "id": "43410",
    "revid": "33011235",
    "url": "https://en.wikipedia.org/wiki?curid=43410",
    "title": "VHDL",
    "text": "The VHSIC Hardware Description Language (VHDL) is a &lt;a href=\"hardware%20description%20language\"&gt;hardware description language&lt;/a&gt; (HDL) that can model the behavior and structure of &lt;a href=\"Digital%20electronics\"&gt;digital systems&lt;/a&gt; at multiple &lt;a href=\"levels%20of%20abstraction\"&gt;levels of abstraction&lt;/a&gt;, ranging from the system level down to that of &lt;a href=\"logic%20gates\"&gt;logic gates&lt;/a&gt;, for design entry, documentation, and verification purposes. Since 1987, VHDL has been standardized by the &lt;a href=\"Institute%20of%20Electrical%20and%20Electronics%20Engineers\"&gt;Institute of Electrical and Electronics Engineers&lt;/a&gt; (IEEE) as IEEE\u00a0Std\u00a01076; the latest version (as of April 2020) of which is IEEE\u00a0Std\u00a01076-2019. To model &lt;a href=\"Analogue%20electronics\"&gt;analog&lt;/a&gt; and &lt;a href=\"Mixed-signal%20integrated%20circuit\"&gt;mixed-signal&lt;/a&gt; systems, an IEEE-standardized HDL based on VHDL called &lt;a href=\"VHDL-AMS\"&gt;VHDL-AMS&lt;/a&gt; (officially IEEE\u00a01076.1) has been developed.\nVHDL is named after the &lt;a href=\"United%20States%20Department%20of%20Defense\"&gt;United States Department of Defense&lt;/a&gt; program that created it, the &lt;a href=\"VHSIC\"&gt;Very High-Speed Integrated Circuits Program&lt;/a&gt; (VHSIC). In the early 1980s, the VHSIC Program sought a new HDL for use in the design of the &lt;a href=\"integrated%20circuits\"&gt;integrated circuits&lt;/a&gt; it aimed to develop. The product of this effort was VHDL Version 7.2, released in 1985. The effort to standardize it as an IEEE standard began in the following year.\nHistory.\nIn 1983, VHDL was originally developed at the behest of the &lt;a href=\"U.S.%20Department%20of%20Defense\"&gt;U.S. Department of Defense&lt;/a&gt; in order to document the behavior of the &lt;a href=\"Application-specific%20integrated%20circuit\"&gt;ASICs&lt;/a&gt; that supplier companies were including in equipment. The standard MIL-STD-454N in Requirement 64 in section 4.5.1 \"ASIC documentation in VHDL\" explicitly requires documentation of \"Microelectronic Devices\" in VHDL.\nThe idea of being able to simulate the ASICs from the information in this documentation was so obviously attractive that &lt;a href=\"Logic%20simulation\"&gt;logic simulators&lt;/a&gt; were developed that could read the VHDL files. The next step was the development of &lt;a href=\"logic%20synthesis\"&gt;logic synthesis&lt;/a&gt; tools that read the VHDL and output a definition of the physical implementation of the circuit.\nDue to the Department of Defense requiring as much of the syntax as possible to be based on Ada, in order to avoid re-inventing concepts that had already been thoroughly tested in the development of Ada, VHDL borrows heavily from the &lt;a href=\"Ada%20%28programming%20language%29\"&gt;Ada programming language&lt;/a&gt; in both concept and &lt;a href=\"syntax\"&gt;syntax&lt;/a&gt;.\nThe initial version of VHDL, designed to &lt;a href=\"IEEE\"&gt;IEEE&lt;/a&gt; standard IEEE 1076-1987, included a wide range of data types, including numerical (&lt;a href=\"integer\"&gt;integer&lt;/a&gt; and &lt;a href=\"real%20data%20type\"&gt;real&lt;/a&gt;), logical (&lt;a href=\"bit\"&gt;bit&lt;/a&gt; and &lt;a href=\"Boolean%20datatype\"&gt;boolean&lt;/a&gt;), &lt;a href=\"character%20%28computing%29\"&gt;character&lt;/a&gt; and &lt;a href=\"time\"&gt;time&lt;/a&gt;, plus &lt;a href=\"Array%20data%20type\"&gt;arrays&lt;/a&gt; of codice_1 called codice_2 and of codice_3 called &lt;a href=\"string%20%28computer%20science%29\"&gt;string&lt;/a&gt;.\nA problem not solved by this edition, however, was \"multi-valued logic\", where a signal's &lt;a href=\"drive%20strength\"&gt;drive strength&lt;/a&gt; (none, weak or strong) and unknown values are also considered. This required &lt;a href=\"IEEE%201164\"&gt;IEEE standard 1164&lt;/a&gt;, which defined the 9-value logic types: scalar codice_4 and its vector version codice_5. Being a resolved subtype of its codice_6 parent type, codice_4-typed signals allow multiple driving for modeling bus structures, whereby the connected resolution function handles conflicting assignments adequately.\nThe updated &lt;a href=\"IEEE%201076\"&gt;IEEE 1076&lt;/a&gt;, in 1993, made the syntax more consistent, allowed more flexibility in naming, extended the codice_3 type to allow &lt;a href=\"ISO-8859-1\"&gt;ISO-8859-1&lt;/a&gt; printable characters, added the codice_9 operator, etc.\nMinor changes in the standard (2000 and 2002) added the idea of protected types (similar to the concept of class in &lt;a href=\"C%2B%2B\"&gt;C++&lt;/a&gt;) and removed some restrictions from port mapping rules.\nIn addition to IEEE standard 1164, several child standards were introduced to extend functionality of the language. IEEE standard 1076.2 added better handling of real and complex data types. IEEE standard 1076.3 introduced &lt;a href=\"Signedness\"&gt;signed and unsigned&lt;/a&gt; types to facilitate arithmetical operations on vectors. IEEE standard 1076.1 (known as &lt;a href=\"VHDL-AMS\"&gt;VHDL-AMS&lt;/a&gt;) provided analog and mixed-signal circuit design extensions.\nSome other standards support wider use of VHDL, notably &lt;a href=\"VHDL-VITAL\"&gt;VITAL&lt;/a&gt; (VHDL Initiative Towards ASIC Libraries) and &lt;a href=\"microwave\"&gt;microwave&lt;/a&gt; circuit design extensions.\nIn June 2006, the VHDL Technical Committee of &lt;a href=\"Accellera\"&gt;Accellera&lt;/a&gt; (delegated by IEEE to work on the next update of the standard) approved so-called Draft 3.0 of VHDL-2006. While maintaining full compatibility with older versions, this proposed standard provides numerous extensions that make writing and managing VHDL code easier. Key changes include incorporation of child standards (1164, 1076.2, 1076.3) into the main 1076 standard, an extended set of operators, more flexible syntax of \"case\" and \"generate\" statements, incorporation of VHPI (VHDL Procedural Interface) (interface to C/C++ languages) and a subset of PSL (&lt;a href=\"Property%20Specification%20Language\"&gt;Property Specification Language&lt;/a&gt;). These changes should improve quality of synthesizable VHDL code, make testbenches more flexible, and allow wider use of VHDL for system-level descriptions.\nIn February 2008, Accellera approved VHDL 4.0, also informally known as VHDL 2008, which addressed more than 90 issues discovered during the trial period for version 3.0 and includes enhanced generic types. In 2008, Accellera released VHDL 4.0 to the IEEE for balloting for inclusion in IEEE 1076-2008. The VHDL standard IEEE 1076-2008 was published in January 2009.\nStandardization.\nThe &lt;a href=\"IEEE\"&gt;IEEE&lt;/a&gt; Standard 1076 defines the &lt;a href=\"VHSIC\"&gt;VHSIC&lt;/a&gt; &lt;a href=\"Hardware%20Description%20Language\"&gt;Hardware Description Language&lt;/a&gt;, or VHDL. It was originally developed under contract F33615-83-C-1003 from the &lt;a href=\"United%20States%20Air%20Force\"&gt;United States Air Force&lt;/a&gt; awarded in 1983 to a team of Intermetrics, Inc. as language experts and prime contractor, &lt;a href=\"Texas%20Instruments\"&gt;Texas Instruments&lt;/a&gt; as chip design experts and &lt;a href=\"IBM\"&gt;IBM&lt;/a&gt; as computer-system design experts. The language has undergone numerous revisions and has a variety of sub-standards associated with it that augment or extend it in important ways.\n1076 was and continues to be a milestone in the design of electronic systems.\nDesign.\nVHDL is generally used to write text models that describe a logic circuit. Such a model is processed by a synthesis program, only if it is part of the logic design. A simulation program is used to test the logic design using simulation models to represent the logic circuits that interface to the design. This collection of simulation models is commonly called a \"testbench\".\nA VHDL simulator is typically an &lt;a href=\"event-driven%20simulator\"&gt;event-driven simulator&lt;/a&gt;. This means that each transaction is added to an event queue for a specific scheduled time. E.g. if a signal assignment should occur after 1 nanosecond, the event is added to the queue for time +1ns. Zero delay is also allowed, but still needs to be scheduled: for these cases &lt;a href=\"delta%20delay\"&gt;delta delay&lt;/a&gt; is used, which represent an infinitely small time step. The simulation alters between two modes: statement execution, where triggered statements are evaluated, and event processing, where events in the queue are processed.\nVHDL has constructs to handle the &lt;a href=\"parallel%20computing\"&gt;parallelism&lt;/a&gt; inherent in hardware designs, but these constructs (\"processes\") differ in syntax from the parallel constructs in Ada (\"tasks\"). Like Ada, VHDL is &lt;a href=\"strongly%20typed\"&gt;strongly typed&lt;/a&gt; and is &lt;a href=\"Case%20sensitivity\"&gt;not case sensitive&lt;/a&gt;. In order to directly represent operations which are common in hardware, there are many features of VHDL which are not found in Ada, such as an extended set of Boolean operators including nand and nor.\nVHDL has file input and output capabilities, and can be used as a general-purpose language for text processing, but files are more commonly used by a simulation testbench for stimulus or verification data. There are some VHDL compilers which build executable binaries. In this case, it might be possible to use VHDL to write a \"testbench\" to verify the functionality of the design using files on the host computer to define stimuli, to interact with the user, and to compare results with those expected. However, most designers leave this job to the simulator.\nIt is relatively easy for an inexperienced developer to produce code that simulates successfully but that cannot be synthesized into a real device, or is too large to be practical. One particular pitfall is the accidental production of &lt;a href=\"transparent%20latch\"&gt;transparent latch&lt;/a&gt;es rather than &lt;a href=\"Flip-flop%20%28electronics%29%23D%20flip-flop\"&gt;D-type flip-flops&lt;/a&gt; as storage elements.\nOne can design hardware in a VHDL IDE (for FPGA implementation such as Xilinx ISE, Altera Quartus, Synopsys Synplify or Mentor Graphics HDL Designer) to produce the &lt;a href=\"Register-transfer%20level\"&gt;RTL&lt;/a&gt; schematic of the desired circuit. After that, the generated schematic can be verified using simulation software which shows the waveforms of inputs and outputs of the circuit after generating the appropriate testbench. To generate an appropriate testbench for a particular circuit or VHDL code, the inputs have to be defined correctly. For example, for clock input, a loop process or an iterative statement is required.\nA final point is that when a VHDL model is translated into the \"gates and wires\" that are mapped onto a programmable logic device such as a &lt;a href=\"CPLD\"&gt;CPLD&lt;/a&gt; or &lt;a href=\"FPGA\"&gt;FPGA&lt;/a&gt;, then it is the actual hardware being configured, rather than the VHDL code being \"executed\" as if on some form of a processor chip.\nAdvantages.\nThe key advantage of VHDL, when used for systems design, is that it allows the behavior of the required system to be described (modeled) and verified (simulated) before synthesis tools translate the design into real hardware (gates and wires).\nAnother benefit is that VHDL allows the description of a &lt;a href=\"concurrent%20system\"&gt;concurrent system&lt;/a&gt;. VHDL is a &lt;a href=\"Dataflow%20programming\"&gt;dataflow language&lt;/a&gt; in which every statement is considered for execution simultaneously, unlike procedural computing languages such as BASIC, C, and assembly code, where a sequence of statements is run sequentially one instruction at a time.\nA VHDL project is multipurpose. Being created once, a calculation block can be used in many other projects. However, many formational and functional block parameters can be tuned (capacity parameters, memory size, element base, block composition and interconnection structure).\nA VHDL project is portable. Being created for one element base, a computing device project can be ported on another element base, for example &lt;a href=\"VLSI\"&gt;VLSI&lt;/a&gt; with various technologies.\nA big advantage of VHDL compared to original &lt;a href=\"Verilog\"&gt;Verilog&lt;/a&gt; is that VHDL has a full &lt;a href=\"type%20system\"&gt;type system&lt;/a&gt;. Designers can use the type system to write much more structured code (especially by declaring &lt;a href=\"Record%20%28computer%20science%29\"&gt;record&lt;/a&gt; types).\nDesign examples.\nIn VHDL, a design consists at a minimum of an \"entity\" which describes the interface and an \"architecture\" which contains the actual implementation. In addition, most designs import library modules. Some designs also contain multiple architectures and \"configurations\".\nA simple &lt;a href=\"Logic%20gate\"&gt;AND gate&lt;/a&gt; in VHDL would look something like\n-- (this is a VHDL comment)\n this is a block comment (VHDL-2008)\n-- import std_logic from the IEEE library\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\n-- this is the entity\nentity ANDGATE is\n port ( \n I1 : in std_logic;\n I2 : in std_logic;\n O : out std_logic);\nend entity ANDGATE;\n-- this is the architecture\narchitecture RTL of ANDGATE is\nbegin\n O &lt;= I1 and I2;\nend architecture RTL;\n(Notice that codice_10 stands for \"&lt;a href=\"Register%20transfer%20level\"&gt;Register transfer level&lt;/a&gt;\" design.) While the example above may seem verbose to HDL beginners, many parts are either optional or need to be written only once. Generally simple functions like this are part of a larger behavioral module, instead of having a separate module for something so simple. In addition, use of elements such as the codice_4 type might at first seem to be an overkill. One could easily use the built-in codice_1 type and avoid the library import in the beginning. However, using a form of &lt;a href=\"many-valued%20logic\"&gt;many-valued logic&lt;/a&gt;, specifically &lt;a href=\"IEEE%201164\"&gt;9-valued logic&lt;/a&gt; (codice_13,codice_14,codice_15,codice_16,codice_17,codice_18,codice_19,codice_20,codice_21), instead of simple bits (0,1) offers a very powerful simulation and debugging tool to the designer which currently does not exist in any other HDL.\nIn the examples that follow, you will see that VHDL code can be written in a very compact form. However, more experienced designers usually avoid these compact forms and use a more verbose coding style for the sake of readability and maintainability.\nSynthesizable constructs and VHDL templates.\nVHDL is frequently used for two different goals: simulation of electronic designs and synthesis of such designs. Synthesis is a process where a VHDL is compiled and mapped into an implementation technology such as an FPGA or an ASIC.\nNot all constructs in VHDL are suitable for synthesis. For example, most constructs that explicitly deal with timing such as codice_22 are not synthesizable despite being valid for simulation. While different synthesis tools have different capabilities, there exists a common \"synthesizable subset\" of VHDL that defines what language constructs and idioms map into common hardware for many synthesis tools. IEEE 1076.6 defines a subset of the language that is considered the official synthesis subset. It is generally considered a \"best practice\" to write very idiomatic code for synthesis as results can be incorrect or suboptimal for non-standard constructs.\nMUX template.\nThe &lt;a href=\"multiplexer\"&gt;multiplexer&lt;/a&gt;, or 'MUX' as it is usually called, is a simple construct very common in hardware design. The example below demonstrates a simple two to one MUX, with inputs codice_23 and codice_24, selector codice_25 and output codice_14. Note that there are many other ways to express the same MUX in VHDL.\nX &lt;= A when S = '1' else B;\nLatch template.\nA &lt;a href=\"transparent%20latch\"&gt;transparent latch&lt;/a&gt; is basically one bit of memory which is updated when an enable signal is raised. Again, there are many other ways this can be expressed in VHDL.\n-- latch template 1:\nQ &lt;= D when Enable = '1' else Q;\n-- latch template 2:\nprocess(all)\nbegin\n Q &lt;= D when(Enable);\nend process;\nD-type flip-flops.\nThe D-type &lt;a href=\"Flip-flop%20%28electronics%29\"&gt;flip-flop&lt;/a&gt; samples an incoming signal at the rising (or falling) edge of a clock. This example has an asynchronous, active-high reset, and samples at the rising clock edge.\nDFF : process(all) is\nbegin\n if RST then\n Q &lt;= '0';\n elsif rising_edge(CLK) then\n Q &lt;= D;\n end if;\nend process DFF;\nAnother common way to write edge-triggered behavior in VHDL is with the 'event' signal attribute. A single apostrophe has to be written between the signal name and the name of the attribute.\nDFF : process(RST, CLK) is\nbegin\n if RST then\n Q &lt;= '0';\n elsif CLK'event and CLK = '1' then\n Q &lt;= D;\n end if;\nend process DFF;\nVHDL also lends itself to \"one-liners\" such as\nDFF : Q &lt;= '0' when RST = '1' else D when rising_edge(clk);\nor\nDFF : process(all) is \nbegin\n if rising_edge(CLK) then\n Q &lt;= D;\n Q2 &lt;= Q1;\n end if;\n if RST then\n Q &lt;= '0';\n end if;\nend process DFF;\nWhich can be useful if not all signals (registers) driven by this process should be reset.\nExample: a counter.\nThe following example is an up-counter with asynchronous reset, parallel load and configurable width. It demonstrates the use of the 'unsigned' type, type conversions between 'unsigned' and 'std_logic_vector' and VHDL \"generics\". The generics are very close to arguments or templates in other traditional programming languages like C++.\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\nuse IEEE.numeric_std.all; -- for the unsigned type\nentity COUNTER is\n generic (\n WIDTH : in natural := 32);\n port (\n RST : in std_logic;\n CLK : in std_logic;\n LOAD : in std_logic;\n DATA : in std_logic_vector(WIDTH-1 downto 0);\n Q : out std_logic_vector(WIDTH-1 downto 0));\nend entity COUNTER;\narchitecture RTL of COUNTER is\nbegin\n process(all) is\n begin\n if RST then\n Q &lt;= (others =&gt; '0');\n elsif rising_edge(CLK) then\n if LOAD then\n Q &lt;= DATA;\n else\n Q &lt;= std_logic_vector(unsigned(Q) + 1); --Addition is unsigned, converted back to std_logic_vector\n end if;\n end if;\n end process;\nend architecture RTL;\nMore complex counters may add if/then/else statements within the codice_27 to add other functions, such as count enables, stopping or rolling over at some count value, generating output signals like terminal count signals, etc. Care must be taken with the ordering and nesting of such controls if used together, in order to produce the desired priorities and minimize the number of logic levels needed.\nSimulation-only constructs.\nA large subset of VHDL cannot be translated into hardware. This subset is known as the non-synthesizable or the simulation-only subset of VHDL and can only be used for prototyping, simulation and debugging. For example, the following code will generate a clock with a frequency of 50\u00a0MHz. It can, for example, be used to drive a clock input in a design during simulation. It is, however, a simulation-only construct and cannot be implemented in hardware. In actual hardware, the clock is generated externally; it can be scaled down internally by user logic or dedicated hardware.\nprocess\nbegin\n CLK &lt;= '1'; wait for 10 NS;\n CLK &lt;= '0'; wait for 10 NS;\nend process;\nThe simulation-only constructs can be used to build complex waveforms in very short time. Such waveform can be used, for example, as test vectors for a complex design or as a prototype of some synthesizer logic that will be implemented in the future.\nprocess\nbegin\n wait until START = '1'; -- wait until START is high\n for i in 1 to 10 loop -- then wait for a few clock periods...\n wait until rising_edge(CLK);\n end loop;\n for i in 1 to 10 loop -- write numbers 1 to 10 to DATA, 1 every cycle\n DATA &lt;= to_unsigned(i, 8);\n wait until rising_edge(CLK);\n end loop;\n -- wait until the output changes\n wait on RESULT;\n -- now raise ACK for clock period\n ACK &lt;= '1';\n wait until rising_edge(CLK);\n ACK &lt;= '0';\n -- and so on...\nend process;\nStandard libraries.\nAlso referred as standard packages.\nIEEE Standard Package.\nThe IEEE Standard Package includes the following:\nVHDL simulators.\nCommercial:\nOther:"
}