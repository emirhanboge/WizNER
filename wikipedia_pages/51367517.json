{
    "id": "51367517",
    "revid": "7903804",
    "url": "https://en.wikipedia.org/wiki?curid=51367517",
    "title": "Counter-based random number generator (CBRNG)",
    "text": "A counter-based random number generation (CBRNG, also known as a counter-based pseudo-random number generator, or CBPRNG) is a kind of &lt;a href=\"pseudorandom%20number%20generator\"&gt;pseudorandom number generator&lt;/a&gt; that uses only an integer counter as its internal state.\nBackground.\nWe can think of a pseudorandom number generator (PRNG) as a function that transforms a series of bits known as the \"state\" into a new state and a random number.\nThat is, given a PRNG function and an initial state formula_1, we can repeatedly use the PRNG to generate a sequence of states and random numbers.\nformula_2\nIn some PRNGs, such as the &lt;a href=\"Mersenne%20Twister\"&gt;Mersenne Twister&lt;/a&gt;, the state is large, more than 2048 bytes. In other PRNGs, such as &lt;a href=\"xorshift\"&gt;xorshift&lt;/a&gt;, formula_3 and formula_4 are one and the same (and so the state is small, just 4, 8, or 16 bytes, depending on the size of the numbers being generated). But in both cases, and indeed in most traditional PRNGs, the state evolves unpredictably, so if you want to calculate a particular formula_3 given an initial state formula_1, you have to calculate formula_7, formula_8, and so on, running the PRNG formula_9 times.\nSuch algorithms are inherently \"sequential\" and not amenable to running on parallel machines like &lt;a href=\"multi-core%20CPU\"&gt;multi-core CPUs&lt;/a&gt; and &lt;a href=\"GPU\"&gt;GPUs&lt;/a&gt;.\nIn contrast, a counter-based random number generator (CBRNG) is a PRNG where the state \"evolves\" in a particularly simple manner: formula_10. This way you can generate each number independently, without knowing the result of the previous call to the PRNG.\nThis property make it easy to run a CBRNG on a multiple CPU threads or a GPU. For example, to generate formula_11 random numbers on a GPU, you might spawn formula_11 threads and have the formula_9th thread calculate formula_14.\nCBRNGs based on block ciphers.\nSome CBRNGs are based on reduced-strength versions of &lt;a href=\"block%20cipher\"&gt;block cipher&lt;/a&gt;s. Below we explain how this works.\nWhen using a cryptograhpic &lt;a href=\"block%20cipher\"&gt;block cipher&lt;/a&gt; in &lt;a href=\"Block%20cipher%20mode%20of%20operation%23CTR\"&gt;counter mode&lt;/a&gt;, you generate a series of blocks of random bits. The formula_9th block is calculated by encrypting the number formula_9 using the encryption key formula_17: formula_18.\nThis is similar to a CBRNG, where you calculate the formula_9th random number as formula_14. Indeed, any block cipher can be used as a CBRNG; simply let formula_21!\nThis yields a strong, &lt;a href=\"Cryptographically%20secure%20pseudorandom%20number%20generator\"&gt;cryptographically-secure source of randomness&lt;/a&gt;. But cryptographically-secure pseudorandom number generators tend to be slow compared to insecure PRNGs, and in practice many uses of random numbers don't require this degree of security.\nIn 2011, Salmon et al. at &lt;a href=\"D.%20E.%20Shaw%20Research\"&gt;D. E. Shaw Research&lt;/a&gt; introduced two CBRNGs based on reduced-strength versions of block ciphers.\nARS is used in recent versions of Intel's &lt;a href=\"Math%20Kernel%20Library\"&gt;Math Kernel Library&lt;/a&gt; and gets good performance by using instructions from the &lt;a href=\"AES-NI\"&gt;AES-NI&lt;/a&gt; instruction set, which specifically accelerate AES encryption.\nCode implementing Threefry, ARS, and Philox (see below) is available from the authors.\nCBRNGs based on multiplication.\nIn addition to Threefry and ARS, Salmon et al. described a third counter-based PRNG, &lt;a href=\"Philox\"&gt;Philox&lt;/a&gt;. It's based on wide multiplies, e.g. multiplying two 32-bit numbers and producing a 64-bit number, or multiplying two 64-bit numbers and producing a 128-bit number.\nAs of 2020, Philox is popular on CPUs and GPUs. On GPUs, &lt;a href=\"nVidia\"&gt;nVidia&lt;/a&gt;'s cuRAND library and &lt;a href=\"TensorFlow\"&gt;TensorFlow&lt;/a&gt; provide implementations of Philox. On CPUs, Intel's &lt;a href=\"Math%20Kernel%20Library\"&gt;MKL&lt;/a&gt; provides an implementation."
}