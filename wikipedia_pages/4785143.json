{
    "id": "4785143",
    "revid": "84591",
    "url": "https://en.wikipedia.org/wiki?curid=4785143",
    "title": "Semipredicate problem",
    "text": "In &lt;a href=\"computer%20programming\"&gt;computer programming&lt;/a&gt;, a semipredicate problem occurs when a &lt;a href=\"subroutine\"&gt;subroutine&lt;/a&gt; intended to return a useful value can fail, but the signalling of failure uses an otherwise valid &lt;a href=\"return%20value\"&gt;return value&lt;/a&gt;. The problem is that the caller of the subroutine cannot tell what the result means in this case.\nExample.\nThe &lt;a href=\"Division%20%28mathematics%29\"&gt;division&lt;/a&gt; operation yields a &lt;a href=\"real%20number\"&gt;real number&lt;/a&gt;, but fails when the divisor is &lt;a href=\"0%20%28number%29\"&gt;zero&lt;/a&gt;. If we were to write a function that performs division, we might choose to return 0 on this invalid input. However, if the dividend is 0, the result is 0 too. This means there is no number we can return to uniquely signal attempted division by zero, since all real numbers are in the &lt;a href=\"range%20of%20a%20function\"&gt;range&lt;/a&gt; of division.\nPractical implications.\nEarly programmers dealt with potentially exceptional cases, as in the case of division, using a &lt;a href=\"Convention%20%28norm%29\"&gt;convention&lt;/a&gt; that required the calling routine to check the validity of the inputs before calling the division function. This had two problems. First, it greatly encumbers all code that performs division (a very common operation). Second, it violates the &lt;a href=\"Don%27t%20repeat%20yourself\"&gt;Don't repeat yourself&lt;/a&gt; and &lt;a href=\"encapsulation%20%28computer%20science%29\"&gt;encapsulation&lt;/a&gt; principles, where the former is about eliminating duplicated code, and the latter suggests that data associated code should be contained in one place (in this case the verification of input was done separately). If we imagine a more complicated computation than division, it could be hard for the caller to know what is considered invalid input; in some cases figuring out whether the input is valid may be as costly as performing the entire computation, there's also the possibility of the target function being modified and then expecting different preconditions than the ones the caller has checked for, such a change would require changes in all the places where the function was called from.\nSolutions.\nThe semipredicate problem is not universal among functions that can fail.\nUsing a custom convention to interpret return values.\nIf the function's range does not cover the entire &lt;a href=\"data%20type\"&gt;data type&lt;/a&gt; defined for the function, a value known to be impossible under normal computation can be used. For example, consider the function codice_1, which takes a string and a substring, and returns the &lt;a href=\"integer\"&gt;integer&lt;/a&gt; index of the substring in the main string. If the search fails, the function may be programmed to return -32,768 (or any other negative value), since this can never signify a successful result.\nThis solution has its problems, though, as it overloads the natural meaning of a function with an arbitrary convention.\nMultivalued return.\nMany languages allow, through one mechanism or another, a function to return multiple values. If this is available, the function can be redesigned to return a boolean value signalling success or failure, in addition to its primary return value. If multiple error modes are possible, the function may instead return an enumerated &lt;a href=\"return%20code\"&gt;return code&lt;/a&gt; (error code) in addition to its primary return value.\nVarious techniques for returning multiple values include:\nGlobal variable for return status.\nSimilar to an \"out\" argument, a &lt;a href=\"global%20variable\"&gt;global variable&lt;/a&gt; can store what error occurred (or simply whether an error occurred).\nFor instance, if an error occurs, and is signalled (generally as above, by an illegal value like \u22121) the Unix codice_4 variable is set to indicate which value occurred. Using a global has its usual drawbacks: &lt;a href=\"thread%20safety\"&gt;thread safety&lt;/a&gt; becomes a concern (modern operating systems use a thread-safe version of errno), and if only one error global is used, its type must be wide enough to contain all interesting information about all possible errors in the system.\nExceptions.\n&lt;a href=\"Exception%20handling\"&gt;Exceptions&lt;/a&gt; are one widely used scheme for solving this problem. An error condition is not considered a return value of the function at all; normal &lt;a href=\"control%20flow\"&gt;control flow&lt;/a&gt; is disrupted and explicit handling of the error takes place automatically. They are an example of &lt;a href=\"out-of-band%20signalling\"&gt;out-of-band signalling&lt;/a&gt;.\nExpanding the return value type.\nManually created hybrid types.\nIn &lt;a href=\"C%20%28programming%20language%29\"&gt;C&lt;/a&gt;, a common approach, when possible, is to use a data type deliberately wider than strictly needed by the function. For example, the standard function codice_5 is defined with return type codice_6 and returns a value in the range [0,255] (the range of codice_7) on success or the value codice_8 (&lt;a href=\"Unspecified%20behavior%23Implementation-defined%20behavior\"&gt;implementation-defined&lt;/a&gt;, but outside the range of codice_7) on the end of the input or a read error.\nNullable reference types.\nIn languages with pointers or references, one solution is to return a pointer to a value, rather than the value itself. This return pointer can then be set to &lt;a href=\"null%20pointer\"&gt;null&lt;/a&gt; to indicate an error. It is typically suited to functions that return a pointer anyway. This has a performance advantage over the OOP style of exception handling, with the drawback that negligent programmers may not check the return value, resulting in a &lt;a href=\"Crash%20%28computing%29\"&gt;crash&lt;/a&gt; when the invalid pointer is used. A common pattern in the &lt;a href=\"UNIX\"&gt;UNIX&lt;/a&gt; environment is setting a separate &lt;a href=\"errno.h\"&gt;variable&lt;/a&gt; to indicate the cause of an error. An example of this is the &lt;a href=\"C%20standard%20library\"&gt;C standard library&lt;/a&gt; codice_10 function.\nImplicitly hybrid types.\nIn &lt;a href=\"Dynamic%20typing\"&gt;dynamically-typed&lt;/a&gt; languages, such as &lt;a href=\"PHP\"&gt;PHP&lt;/a&gt; and &lt;a href=\"Lisp%20%28programming%20language%29\"&gt;Lisp&lt;/a&gt;, the usual approach is to return \"false\", \"none\" or \"null\" when the function call fails. This works by returning a different type to the normal return type (thus expanding the type). It is a dynamically-typed equivalent to returning a null pointer.\nFor example, a numeric function normally returns a number (int or float), and while zero might be a valid response; false is not. Similarly, a function that normally returns a string might sometimes return the empty string as a valid response, but return false on failure. This process of type-juggling necessitates care in testing the return value: e.g. in PHP, use codice_11 (i.e. equal and of same type) rather than just codice_12 (i.e. equal, after automatic type-conversion). It works only when the original function is not meant to return a boolean value, and still requires that information about the error be conveyed via other means.\nExplicitly hybrid types.\nIn &lt;a href=\"Haskell%20language\"&gt;Haskell&lt;/a&gt; and other &lt;a href=\"functional%20programming%20language\"&gt;functional programming language&lt;/a&gt;s, it is common to use a data type that is just as big as it needs to be to express any possible result. For example, we could write a division function that returned the type codice_13, and a codice_14 function returning codice_15. The first is an &lt;a href=\"option%20type\"&gt;option type&lt;/a&gt;, which has only one failure value, codice_16. The second case is a &lt;a href=\"tagged%20union\"&gt;tagged union&lt;/a&gt;: a result is either some string with a descriptive error message, or a successfully read character. Haskell's &lt;a href=\"type%20inference\"&gt;type inference&lt;/a&gt; system helps ensure that callers deal with possible errors. Since the error conditions become explicit in the function type, looking at its signature immediately tells the programmer how to treat errors. In addition, tagged unions and option types form &lt;a href=\"Monads%20in%20functional%20programming\"&gt;monads&lt;/a&gt; when endowed with appropriate functions: this may be used to keep the code tidy by automatically propagating unhandled error conditions."
}