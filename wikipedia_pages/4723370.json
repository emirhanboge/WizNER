{
    "id": "4723370",
    "revid": "11498870",
    "url": "https://en.wikipedia.org/wiki?curid=4723370",
    "title": "Enumerated type",
    "text": "In &lt;a href=\"computer%20programming\"&gt;computer programming&lt;/a&gt;, an enumerated type (also called enumeration, enum, or factor in the &lt;a href=\"R%20%28programming%20language%29\"&gt;R programming language&lt;/a&gt;, and a &lt;a href=\"categorical%20variable\"&gt;categorical variable&lt;/a&gt; in statistics) is a &lt;a href=\"data%20type\"&gt;data type&lt;/a&gt; consisting of a set of named &lt;a href=\"value%20%28computer%20science%29\"&gt;values&lt;/a&gt; called \"elements\", \"members\", \"enumeral\", or \"enumerators\" of the type. The enumerator names are usually &lt;a href=\"identifier\"&gt;identifier&lt;/a&gt;s that behave as &lt;a href=\"constant%20%28programming%29\"&gt;constants&lt;/a&gt; in the language. An enumerated type can be seen as a degenerate &lt;a href=\"tagged%20union\"&gt;tagged union&lt;/a&gt; of &lt;a href=\"unit%20type\"&gt;unit type&lt;/a&gt;. A &lt;a href=\"variable%20%28computer%20science%29\"&gt;variable&lt;/a&gt; that has been &lt;a href=\"declaration%20%28computer%20science%29\"&gt;declared&lt;/a&gt; as having an enumerated type can be assigned any of the enumerators as a value. In other words, an enumerated type has values that are different from each other, and that can be compared and assigned, but are not specified by the programmer as having any particular concrete representation in the computer's memory; compilers and interpreters can represent them arbitrarily.\nFor example, the four &lt;a href=\"Suit%20%28cards%29\"&gt;suits&lt;/a&gt; in a deck of playing cards may be four enumerators named \"Club\", \"Diamond\", \"Heart\", and \"Spade\", belonging to an enumerated type named \"suit\". If a variable \"V\" is declared having \"suit\" as its data type, one can assign any of those four values to it.\nAlthough the enumerators are usually distinct, some languages may allow the same enumerator to be listed twice in the type's declaration. The names of enumerators need not be semantically complete or compatible in any sense. For example, an enumerated type called \"color\" may be defined to consist of the enumerators \"Red\", \"Green\", \"Zebra\", \"Missing\", and \"Bacon\". In some languages, the declaration of an enumerated type also intentionally defines an &lt;a href=\"total%20order\"&gt;ordering&lt;/a&gt; of its members; in others, the enumerators are unordered; in others still, an implicit ordering arises from the compiler concretely representing enumerators as integers.\nSome enumerator types may be &lt;a href=\"built-in%20type\"&gt;built into&lt;/a&gt; the language. The &lt;a href=\"Boolean%20type\"&gt;Boolean type&lt;/a&gt;, for example is often a pre-defined enumeration of the values \"False\" and \"True\". Many languages allow users to define new enumerated types.\nValues and variables of an enumerated type are usually implemented as fixed-length &lt;a href=\"bit%20string\"&gt;bit string&lt;/a&gt;s, often in a format and size compatible with some &lt;a href=\"integer%20%28computer%20science%29\"&gt;integer&lt;/a&gt; type. Some languages, especially &lt;a href=\"system%20programming%20language\"&gt;system programming language&lt;/a&gt;s, allow the user to specify the bit combination to be used for each enumerator. In &lt;a href=\"type%20theory\"&gt;type theory&lt;/a&gt;, enumerated types are often regarded as &lt;a href=\"tagged%20union\"&gt;tagged union&lt;/a&gt;s of &lt;a href=\"unit%20type\"&gt;unit type&lt;/a&gt;s. Since such types are of the form formula_1, they may also be written as natural numbers.\nRationale.\nSome early programming languages did not originally have enumerated types. If a programmer wanted a variable, for example \"myColor\", to have a value of red, the variable red would be declared and assigned some arbitrary value, usually an integer constant. The variable red would then be assigned to \"myColor\". Other techniques assigned arbitrary values to strings containing the names of the enumerators.\nThese arbitrary values were sometimes referred to as &lt;a href=\"magic%20number%20%28programming%29\"&gt;magic numbers&lt;/a&gt; since there often was no explanation as to how the numbers were obtained or whether their actual values were significant. These magic numbers could make the source code harder for others to understand and maintain.\nEnumerated types, on the other hand, make the code more self-documenting. Depending on the language, the compiler could automatically assign default values to the enumerators thereby hiding unnecessary detail from the programmer. These values may not even be visible to the programmer (see &lt;a href=\"information%20hiding\"&gt;information hiding&lt;/a&gt;). Enumerated types can also prevent a programmer from writing illogical code such as performing mathematical operations on the values of the enumerators. If the value of a variable that was assigned an enumerator were to be printed, some programming languages could also print the name of the enumerator rather than its underlying numerical value. A further advantage is that enumerated types can allow compilers to enforce semantic correctness. For instance:\ncodice_1 \ncan be forbidden, whilst \ncodice_2\nis accepted, even if \"TRIANGLE\" and \"RED\" are both internally represented as \"1\".\nConceptually, an enumerated type is similar to a list of &lt;a href=\"nominal%20number\"&gt;nominals&lt;/a&gt; (numeric codes), since each possible value of the type is assigned a distinctive natural number. A given enumerated type is thus a concrete implementation of this notion. When order is meaningful and/or used for comparison, then an enumerated type becomes an &lt;a href=\"ordinal%20number\"&gt;ordinal&lt;/a&gt; type.\nConventions.\n&lt;a href=\"Programming%20languages\"&gt;Programming languages&lt;/a&gt; tend to have their own, oftentimes multiple, &lt;a href=\"programming%20styles\"&gt;programming styles&lt;/a&gt; and &lt;a href=\"Naming%20convention%20%28programming%29\"&gt;naming conventions&lt;/a&gt;. The variable assigned to an enumeration is usually a noun in singular form, and frequently follows either a &lt;a href=\"PascalCase\"&gt;PascalCase&lt;/a&gt; or &lt;a href=\"uppercase\"&gt;uppercase&lt;/a&gt; convention, while &lt;a href=\"lowercase\"&gt;lowercase&lt;/a&gt; and others are seen less frequently.\nSyntax in several programming languages.\nPascal and syntactically similar languages.\nPascal.\nIn &lt;a href=\"Pascal%20%28programming%20language%29\"&gt;Pascal&lt;/a&gt;, an enumerated type can be implicitly declared by listing the values in a parenthesised list:\n var\n suit: (clubs, diamonds, hearts, spades);\nThe declaration will often appear in a type synonym declaration, such that it can be used for multiple variables:\n type\n cardsuit = (clubs, diamonds, hearts, spades);\n card = record\n suit: cardsuit;\n value: 1 .. 13;\n end;\n var\n hand: array [ 1 .. 13 ] of card;\n trump: cardsuit;\nThe order in which the enumeration values are given matters. An enumerated type is an ordinal type, and the codice_3 and codice_4 functions will give the prior or next value of the enumeration, and codice_5 can convert enumeration values to their integer representation. Standard Pascal does not offer a conversion from arithmetic types to enumerations, however. Extended Pascal offers this functionality via an extended codice_4 function. Some other Pascal dialects allow it via type-casts. Some modern descendants of Pascal, such as &lt;a href=\"Modula-3\"&gt;Modula-3&lt;/a&gt;, provide a special conversion syntax using a method called codice_7; Modula-3 also treats codice_8 and codice_9 as special pre-defined enumerated types and uses codice_10 and codice_7 for standard &lt;a href=\"ASCII\"&gt;ASCII&lt;/a&gt; decoding and encoding.\nPascal style languages also allow enumeration to be used as array index:\n var\n suitcount: array [cardsuit] of integer;\nAda.\nIn &lt;a href=\"Ada%20%28programming%20language%29\"&gt;Ada&lt;/a&gt;, the use of \"=\" was replaced with \"is\" leaving the definition quite similar:\n type Cardsuit is (clubs, diamonds, hearts, spades);\nIn addition to codice_12, codice_13, codice_14 and codice_15 Ada also supports simple string conversions via codice_16 and codice_17.\nSimilar to C-style languages Ada allows the internal representation of the enumeration to be specified:\nfor Cardsuit use\n (clubs =&gt; 1, diamonds =&gt; 2, hearts =&gt; 4, spades =&gt; 8);\nUnlike C-style languages Ada also allows the number of bits of the enumeration to be specified:\nfor Cardsuit'Size use 4; -- 4 bits\nAdditionally, one can use enumerations as indexes for arrays, like in Pascal, but there are attributes defined for enumerations\n Shuffle : constant array(Cardsuit) of Cardsuit :=\n (Clubs =&gt; Cardsuit'Succ(Clubs), -- see attributes of enumerations 'First, 'Last, 'Succ, 'Pred\n Diamonds =&gt; Hearts, --an explicit value\n Hearts =&gt; Cardsuit'Last, --first enumeration value of type Cardsuit e.g., clubs\n Spades =&gt; Cardsuit'First --last enumeration value of type Cardsuit e.g., spades\nLike &lt;a href=\"Modula-3\"&gt;Modula-3&lt;/a&gt; Ada treats codice_18 and codice_19 as special pre-defined (in package \"codice_20\") enumerated types. Unlike Modula-3 one can also define own character types:\ntype Cards is ('7', '8', '9', 'J', 'Q', 'K', 'A');\nC and syntactically similar languages.\nC.\nThe original &lt;a href=\"K%26amp%3BR%20C\"&gt;K&amp;R&lt;/a&gt; dialect of the programming language &lt;a href=\"C%20%28programming%20language%29\"&gt;C&lt;/a&gt; had no enumerated types. In C, enumerations are created by explicit definitions (the codice_21 keyword by itself does not cause allocation of storage) which use the codice_21 keyword and are reminiscent of &lt;a href=\"struct%20%28C%20programming%20language%29\"&gt;struct&lt;/a&gt; and &lt;a href=\"Union%20type\"&gt;union&lt;/a&gt; definitions:\nenum cardsuit {\n Clubs,\n Diamonds,\n Hearts,\n Spades\nstruct card {\n enum cardsuit suit;\n short int value;\n} hand[13];\nenum cardsuit trump;\nC exposes the integer representation of enumeration values directly to the programmer. Integers and enum values can be mixed freely, and all arithmetic operations on enum values are permitted. It is even possible for an enum variable to hold an integer that does not represent any of the enumeration values. In fact, according to the language definition, the above code will define codice_23, codice_24, codice_25, and codice_26 as constants of type codice_27, which will only be converted (silently) to codice_28 if they are stored in a variable of that type.\nC also allows the programmer to choose the values of the enumeration constants explicitly, even without type. For example,\nenum cardsuit {\n Clubs = 1,\n Diamonds = 2,\n Hearts = 4,\n Spades = 8\ncould be used to define a type that allows mathematical sets of suits to be represented as an codice_28 by bitwise logic operations.\nC#.\nEnumerated types in the &lt;a href=\"C%20Sharp%20%28programming%20language%29\"&gt;C#&lt;/a&gt; programming language preserve most of the \"small integer\" semantics of C's enums. Some arithmetic operations are not defined for enums, but an enum value can be explicitly converted to an integer and back again, and an enum variable can have values that were not declared by the enum definition. For example, given\nenum Cardsuit\n Clubs,\n Diamonds,\n Spades,\n Hearts\nthe expressions codice_30 and codice_31 are allowed directly (because it may make sense to step through the sequence of values or ask how many steps there are between two values), but codice_32 is deemed to make less sense and is only allowed if the values are first converted to integers.\nC# also provides the C-like feature of being able to define specific integer values for enumerations. By doing this it is possible to perform binary operations on enumerations, thus treating enumeration values as sets of flags. These flags can be tested using binary operations or with the Enum type's builtin 'HasFlag' method.\nThe enumeration definition defines names for the selected integer values and is &lt;a href=\"syntactic%20sugar\"&gt;syntactic sugar&lt;/a&gt;, as it is possible to assign to an enum variable other integer values that are not in the scope of the enum definition.\nC++.\n&lt;a href=\"C%2B%2B\"&gt;C++&lt;/a&gt; has enumeration types that are directly inherited from C's and work mostly like these, except that an enumeration is a real type in C++, giving added compile-time checking. Also (as with structs), the C++ codice_21 keyword is automatically combined with a , so that instead of naming the type codice_34, simply name it codice_35. This can be simulated in C using a typedef: \n&lt;a href=\"C%2B%2B11\"&gt;C++11&lt;/a&gt; provides a second, type-safe enumeration type that is not implicitly converted to an integer type. It allows io streaming to be defined for that type. Additionally the enumerations do not leak, so they have to be used with Enumeration codice_36. This is specified by the phrase \"enum class\". For example:\nenum class Color {Red, Green, Blue};\nThe \"underlying type\" is an implementation-defined integral type that is large enough to hold all enumerated values (it doesn't have to be the smallest possible type!). In C++ you can specify the underlying type directly. That allows \"forward declarations\" of enumerations:\nenum class Color : long {Red, Green, Blue}; // must fit in size and memory layout the type 'long'\nenum class Shapes : char; // forward declaration. If later there are values defined that don't fit in 'char' it is an error.\nGo.\n&lt;a href=\"Go%20%28programming%20language%29\"&gt;Go&lt;/a&gt; uses the codice_37 keyword to create enumerated constants.\ntype ByteSize float64\nconst (\n _ = iota // ignore first value by assigning to blank identifier\n KB ByteSize = 1 \u00ab (10 * iota)\n MB\n GB\nJava.\nThe J2SE version 5.0 of the &lt;a href=\"Java%20%28programming%20language%29\"&gt;Java programming language&lt;/a&gt; added enumerated types whose declaration syntax is\nsimilar to that of &lt;a href=\"C%20%28programming%20language%29\"&gt;C&lt;/a&gt;:\nenum Cardsuit { CLUBS, DIAMONDS, SPADES, HEARTS };\nCardsuit trump;\nThe Java type system, however, treats enumerations as a type separate from integers, and intermixing of enum and integer values is not allowed. In fact, an enum type in Java is actually a special compiler-generated &lt;a href=\"class%20%28computer%20science%29\"&gt;class&lt;/a&gt; rather than an arithmetic type, and enum values behave as global pre-generated instances of that class. Enum types can have instance methods and a constructor (the arguments of which can be specified separately for each enum value). All enum types implicitly extend the abstract class. An enum type cannot be instantiated directly.\nInternally, each enum value contains an integer, corresponding to the order in which they are declared in the source code, starting from 0. The programmer cannot set a custom integer for an enum value directly, but one can define &lt;a href=\"constructor%20overloading\"&gt;overloaded constructors&lt;/a&gt; that can then assign arbitrary values to self-defined members of the enum class. Defining getters allows then access to those self-defined members. The internal integer can be obtained from an enum value using the method, and the list of enum values of an enumeration type can be obtained in order using the codice_38 method. It is generally discouraged for programmers to convert enums to integers and vice versa. Enumerated types are codice_39, using the internal integer; as a result, they can be sorted.\nThe Java standard library provides utility classes to use with enumerations. The class implements a codice_40 of enum values; it is implemented as a &lt;a href=\"bit%20array\"&gt;bit array&lt;/a&gt;, which makes it very compact and as efficient as explicit bit manipulation, but safer. The class implements a codice_41 of enum values to object. It is implemented as an array, with the integer value of the enum value serving as the index.\nPerl.\n&lt;a href=\"Dynamically%20typed\"&gt;Dynamically typed&lt;/a&gt; languages in the syntactic tradition of C (e.g., &lt;a href=\"Perl\"&gt;Perl&lt;/a&gt; or &lt;a href=\"JavaScript\"&gt;JavaScript&lt;/a&gt;) do not, in general, provide enumerations. But in Perl programming the same result can be obtained with the shorthand &lt;a href=\"String%20literal\"&gt;strings&lt;/a&gt; &lt;a href=\"List%20%28abstract%20data%20type%29\"&gt;list&lt;/a&gt; and &lt;a href=\"Hash%20table\"&gt;hashes&lt;/a&gt; (possibly &lt;a href=\"Array%20slicing\"&gt;slices&lt;/a&gt;):\nmy @enum = qw(Clubs Diamonds Hearts Spades);\nmy( %set1, %set2 );\n@set1{@enum} = (); # all cleared\n@set2{@enum} = (1) x @enum; # all set to 1\n$set1{Clubs} ... # false\n$set2{Diamonds} ... # true\nRaku.\n&lt;a href=\"Raku%20%28programming%20language%29\"&gt;Raku&lt;/a&gt; (formerly known as Perl 6) supports enumerations. There are multiple ways to declare enumerations in Raku, all creating a back-end Map.\nenum Cat &lt;sphynx siamese bengal shorthair other&gt;; # Using \"quote-words\"\nenum Cat ('sphynx', 'siamese', 'bengal', 'shorthair', 'other'); # Using a list\nenum Cat (sphynx =&gt; 0, siamese =&gt; 1, bengal =&gt; 2, shorthair =&gt; 3, other =&gt; 4); # Using Pair constructors\nenum Cat (:sphynx(0), :siamese(1), :bengal(2), shorthair(3), :other(4)); # Another way of using Pairs, you can also use `:0sphynx`\nPHP.\nEnums were added in PHP version 8.1.\nenum CardSuit\n case Hearts;\n case Diamonds;\n case Clubs;\n case Spades;\nRust.\nThough Rust uses the codice_21 keyword like C, it uses it to describe &lt;a href=\"tagged%20union\"&gt;tagged union&lt;/a&gt;s, which enums can be considered a degenerate form of. Rust's enums are therefore much more flexible and can contain struct and tuple variants.\nenum Message {\n Quit,\n Move { x: i32, y: i32 }, // struct\n Write(String), // single-element tuple\n ChangeColor(i32, i32, i32), // three-element tuple\nSwift.\nIn C, enumerations assign related names to a set of integer values. In &lt;a href=\"Swift%20%28programming%20language%29\"&gt;Swift&lt;/a&gt;, enumerations are much more flexible and need not provide a value for each case of the enumeration. If a value (termed a \"raw\" value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.\nAlternatively, enumeration cases can specify associated values of any type to be stored along with each different case value, much as unions or variants do in other languages. One can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.\nIn Swift, enumerations are a first-class type. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration's current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial case value and can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.\nenum CardSuit {\n case clubs\n case diamonds\n case hearts\n case spades\nUnlike C and &lt;a href=\"Objective-C\"&gt;Objective-C&lt;/a&gt;, Swift enumeration cases are not assigned a default integer value when they are created. In the CardSuit example above, clubs, diamonds, hearts, and spades do not implicitly equal 0, 1, 2 and 3. Instead, the different enumeration cases are fully-fledged values in their own right, with an explicitly-defined type of CardSuit.\nMultiple cases can appear on a single line, separated by commas:\nenum CardSuit {\n case clubs, diamonds, hearts, spades\nWhen working with enumerations that store integer or string raw values, one doesn't need to explicitly assign a raw value for each case because Swift will automatically assign the values.\nFor instance, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn't have a value set, its value is 0.\nThe enumeration below is a refinement of the earlier Planet enumeration, with integer raw values to represent each planet's order from the sun:\nenum Planet: Int {\n case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\nIn the example above, Planet.mercury has an explicit raw value of 1, Planet.venus has an implicit raw value of 2, and so on.\n&lt;a href=\"https%3A//developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html\"&gt;\"Details are found in Swift documentation online here.\"&lt;/a&gt;\nTypeScript.\nTypeScript adds an 'enum' data type to JavaScript.\nenum Cardsuit {Clubs, Diamonds, Hearts, Spades};\nvar c: Cardsuit = Cardsuit.Diamonds;\nBy default, enums number members starting at 0; this can be overridden by setting the value of the first:\nenum Cardsuit {Clubs = 1, Diamonds, Hearts, Spades};\nvar c: Cardsuit = Cardsuit.Diamonds;\nAll the values can be set:\nenum Cardsuit {Clubs = 1, Diamonds = 2, Hearts = 4, Spades = 8};\nvar c: Cardsuit = Cardsuit.Diamonds;\nTypeScript supports mapping the numeric value to its name. For example, this finds the name of the value 2:\nenum Cardsuit {Clubs = 1, Diamonds, Hearts, Spades};\nvar suitName: string = Cardsuit[2];\nalert(suitName);\nPython.\nAn &lt;a href=\"https%3A//docs.python.org/3/library/enum.html\"&gt;codice_21&lt;/a&gt; module was added to the Python standard library in version 3.4.\nfrom enum import Enum\nclass Cards(Enum):\n CLUBS = 1\n DIAMONDS = 2\n HEARTS = 3\n SPADES = 4\nThere is also a &lt;a href=\"https%3A//docs.python.org/3.4/library/enum.html%23functional-api\"&gt;functional API&lt;/a&gt; for creating enumerations with automatically generated indices (starting with one):\nCards = Enum('Cards', 'CLUBS DIAMONDS HEARTS SPADES')\nPython enumerations do not enforce semantic correctness (a meaningless comparison to an incompatible enumeration always returns \"False\" rather than raising a \"TypeError\"):\n\u00bb&gt; Color = Enum(\"Color\", \"RED GREEN BLUE\")\n\u00bb&gt; Shape = Enum(\"Shape\", [\"CIRCLE\", \"TRIANGLE\", \"SQUARE\", \"HEXAGON\"])\n\u00bb&gt; def has_vertices(shape):\n... return shape != Shape.CIRCLE\n\u00bb&gt; has_vertices(Color.GREEN)\nTrue\nFortran.\n&lt;a href=\"Fortran\"&gt;Fortran&lt;/a&gt; only has enumerated types for interoperability with C; hence, the semantics is similar to C and, as in C, the enum values are just integers and no further type check is done. The C example from above can be written in Fortran as\nenum, bind( C )\n enumerator :: CLUBS = 1, DIAMONDS = 2, HEARTS = 4, SPADES = 8\nend enum\nVisual Basic/VBA.\nEnumerated datatypes in &lt;a href=\"Visual%20Basic\"&gt;Visual Basic&lt;/a&gt; (up to version 6) and &lt;a href=\"Visual%20Basic%20for%20Applications\"&gt;VBA&lt;/a&gt; are automatically assigned the \"codice_44\" datatype and also become a datatype themselves:\n'Zero-based\nEnum CardSuit\n Clubs\n Diamonds\n Hearts\n Spades\nEnd Enum\nSub EnumExample()\n Dim suit As CardSuit\n suit = Diamonds\n MsgBox suit\nEnd Sub\nExample Code in &lt;a href=\"VB.NET\"&gt;VB.NET&lt;/a&gt;\nEnum CardSuit\n Clubs\n Diamonds\n Hearts\n Spades\nEnd Enum\nSub EnumExample()\n Dim suit As CardSuit\n suit = CardSuit.Diamonds\n MessageBox.show(suit)\nEnd Sub\nLisp.\n&lt;a href=\"Common%20Lisp\"&gt;Common Lisp&lt;/a&gt; uses the member type specifier, e.g.,\n '(member club diamond heart spade))\nthat states that object is of type cardsuit if it is codice_45 to club, diamond, heart or spade. The member type specifier is not valid as a &lt;a href=\"Common%20Lisp%20Object%20System\"&gt;Common Lisp Object System&lt;/a&gt; (CLOS) parameter specializer, however. Instead, codice_46, which is the equivalent to codice_47 may be used (that is, only one member of the set may be specified with an eql type specifier, however, it may be used as a CLOS parameter specializer.) In other words, to define methods to cover an enumerated type, a method must be defined for each specific element of that type.\nAdditionally,\n `(member ,@elements))\nmay be used to define arbitrary enumerated types at runtime. For instance\nwould refer to a type equivalent to the prior definition of cardsuit, as of course would simply have been using\nbut may be less confusing with the function codice_48 for stylistic reasons.\nAlgebraic data type in functional programming.\nIn &lt;a href=\"functional%20programming\"&gt;functional programming&lt;/a&gt; languages in the &lt;a href=\"ML%20%28programming%20language%29\"&gt;ML&lt;/a&gt; lineage (e.g., &lt;a href=\"Standard%20ML\"&gt;Standard ML&lt;/a&gt; (SML), &lt;a href=\"OCaml\"&gt;OCaml&lt;/a&gt;, and &lt;a href=\"Haskell%20%28programming%20language%29\"&gt;Haskell&lt;/a&gt;), an &lt;a href=\"algebraic%20data%20type\"&gt;algebraic data type&lt;/a&gt; with only &lt;a href=\"nullary%20constructor\"&gt;nullary constructor&lt;/a&gt;s can be used to implement an enumerated type. For example (in the syntax of SML signatures):\ndatatype cardsuit = Clubs | Diamonds | Hearts | Spades\nval hand : card list\nval trump : cardsuit\nIn these languages the small-integer representation is completely hidden from the programmer, if indeed such a representation is employed by the implementation. However, Haskell has the codice_49 &lt;a href=\"type%20class\"&gt;type class&lt;/a&gt; which a type can derive or implement to get a mapping between the type and codice_50.\nDatabases.\nSome &lt;a href=\"database\"&gt;database&lt;/a&gt;s support enumerated types directly. &lt;a href=\"MySQL\"&gt;MySQL&lt;/a&gt; provides an enumerated type codice_51 with allowable values specified as strings when a table is created. The values are stored as numeric indices with the empty string stored as 0, the first string value stored as 1, the second string value stored as 2, etc. Values can be stored and retrieved as numeric indexes or string values.\nExample:\nCREATE TABLE shirts (\n name VARCHAR(40),\n size ENUM('x-small', 'small', 'medium', 'large', 'x-large')\nXML Schema.\n&lt;a href=\"XML%20Schema%20%28W3C%29\"&gt;XML Schema&lt;/a&gt; supports enumerated types through the enumeration facet used for constraining most primitive datatypes such as strings.\n&lt;xs:element name=\"cardsuit\"&gt;\n &lt;xs:simpleType&gt;\n &lt;xs:restriction base=\"xs:string\"&gt;\n &lt;xs:enumeration value=\"Clubs\"/&gt;\n &lt;xs:enumeration value=\"Diamonds\"/&gt;\n &lt;xs:enumeration value=\"Hearts\"/&gt;\n &lt;xs:enumeration value=\"Spades\"/&gt;\n &lt;/xs:restriction&gt;\n &lt;/xs:simpleType&gt;\n&lt;/xs:element&gt;"
}